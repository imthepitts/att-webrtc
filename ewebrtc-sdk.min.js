/*! ewebrtc-sdk_16-04-2015 */
if (function() {
    "use strict";
    var a = {
        "private": {
            factories: {},
            config: {}
        },
        utils: {},
        logManager: {},
        RESTClient: {},
        rtc: {},
        browser: {}
    };
    window.ATT = a
}(), !ATT) var ATT = {};
if (function(a) {
    "use strict";

    function b(a) {
        var b = {},
            c = [],
            d = b;
        return a.split("\r\n").filter(k).forEach(function(a) {
            var b = a[0],
                e = a.slice(2);
            "m" === b && (c.push({
                rtp: [],
                fmtp: []
            }), d = c[c.length - 1]);
            for (var f = 0; f < (g[b] || []).length; f += 1) {
                var h = g[b][f];
                if (h.reg.test(e)) return j(h, d, e)
            }
        }), b.media = c, b
    }

    function c(a, b) {
        b = b || {}, null == a.version && (a.version = 0), null == a.name && (a.name = " "), a.media.forEach(function(a) {
            null == a.payloads && (a.payloads = "")
        });
        var c = b.outerOrder || o,
            d = b.innerOrder || p,
            e = [];
        return c.forEach(function(b) {
            g[b].forEach(function(c) {
                c.name in a ? e.push(n(b, c, a)) : c.push in a && a[c.push].forEach(function(a) {
                    e.push(n(b, c, a))
                })
            })
        }), a.media.forEach(function(a) {
            e.push(n("m", g.m[0], a)), d.forEach(function(b) {
                g[b].forEach(function(c) {
                    c.name in a ? e.push(n(b, c, a)) : c.push in a && a[c.push].forEach(function(a) {
                        e.push(n(b, c, a))
                    })
                })
            })
        }), e.join("\r\n") + "\r\n"
    }
    var d, e, f = {},
        g = {
            v: [{
                name: "version",
                reg: /^(\d*)$/
            }],
            o: [{
                name: "origin",
                reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                format: "%s %s %d %s IP%d %s"
            }],
            s: [{
                name: "name"
            }],
            i: [{
                name: "description"
            }],
            u: [{
                name: "uri"
            }],
            e: [{
                name: "email"
            }],
            p: [{
                name: "phone"
            }],
            z: [{
                name: "timezones"
            }],
            r: [{
                name: "repeats"
            }],
            t: [{
                name: "timing",
                reg: /^(\d*) (\d*)/,
                names: ["start", "stop"],
                format: "%d %d"
            }],
            c: [{
                name: "connection",
                reg: /^IN IP(\d) (\S*)/,
                names: ["version", "ip"],
                format: "IN IP%d %s"
            }],
            b: [{
                push: "bandwidth",
                reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                names: ["type", "limit"],
                format: "%s:%s"
            }],
            m: [{
                reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
                names: ["type", "port", "protocol", "payloads"],
                format: "%s %d %s %s"
            }],
            a: [{
                push: "rtp",
                reg: /^rtpmap:(\d*) ([\w\-]*)\/(\d*)(?:\s*\/(\S*))?/,
                names: ["payload", "codec", "rate", "encoding"],
                format: function(a) {
                    return a.encoding ? "rtpmap:%d %s/%s/%s" : "rtpmap:%d %s/%s"
                }
            }, {
                push: "fmtp",
                reg: /^fmtp:(\d*) (\S*)/,
                names: ["payload", "config"],
                format: "fmtp:%d %s"
            }, {
                name: "control",
                reg: /^control:(.*)/,
                format: "control:%s"
            }, {
                name: "rtcp",
                reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                names: ["port", "netType", "ipVer", "address"],
                format: function(a) {
                    return null != a.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d"
                }
            }, {
                push: "rtcpFbTrrInt",
                reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                names: ["payload", "value"],
                format: "rtcp-fb:%d trr-int %d"
            }, {
                push: "rtcpFb",
                reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                names: ["payload", "type", "subtype"],
                format: function(a) {
                    return null != a.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s"
                }
            }, {
                push: "ext",
                reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
                names: ["value", "uri", "config"],
                format: function(a) {
                    return null != a.config ? "extmap:%s %s %s" : "extmap:%s %s"
                }
            }, {
                push: "crypto",
                reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                names: ["id", "suite", "config", "sessionConfig"],
                format: function(a) {
                    return null != a.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s"
                }
            }, {
                name: "setup",
                reg: /^setup:(\w*)/,
                format: "setup:%s"
            }, {
                name: "mid",
                reg: /^mid:(\w*)/,
                format: "mid:%s"
            }, {
                name: "ptime",
                reg: /^ptime:(\d*)/,
                format: "ptime:%d"
            }, {
                name: "maxptime",
                reg: /^maxptime:(\d*)/,
                format: "maxptime:%d"
            }, {
                name: "direction",
                reg: /^(sendrecv|recvonly|sendonly|inactive)/,
                format: "%s"
            }, {
                name: "iceUfrag",
                reg: /^ice-ufrag:(\S*)/,
                format: "ice-ufrag:%s"
            }, {
                name: "icePwd",
                reg: /^ice-pwd:(\S*)/,
                format: "ice-pwd:%s"
            }, {
                name: "fingerprint",
                reg: /^fingerprint:(\S*) (\S*)/,
                names: ["type", "hash"],
                format: "fingerprint:%s %s"
            }, {
                push: "candidates",
                reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: generation (\d*))?/,
                names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "generation"],
                format: function(a) {
                    var b = "candidate:%s %d %s %d %s %d typ %s";
                    return b += null != a.raddr ? " raddr %s rport %d" : "%v%v", null != a.generation && (b += " generation %d"), b
                }
            }, {
                name: "remoteCandidates",
                reg: /^remote-candidates:(.*)/,
                format: "remote-candidates:%s"
            }, {
                name: "iceOptions",
                reg: /^ice-options:(\S*)/,
                format: "ice-options:%s"
            }, {
                push: "ssrcs",
                reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
                names: ["id", "attribute", "value"],
                format: "ssrc:%d %s:%s"
            }, {
                name: "msidSemantic",
                reg: /^msid-semantic: (\w*) (\S*)/,
                names: ["semantic", "token"],
                format: "msid-semantic: %s %s"
            }, {
                push: "groups",
                reg: /^group:(\w*) (.*)/,
                names: ["type", "mids"],
                format: "group:%s %s"
            }, {
                name: "rtcpMux",
                reg: /^(rtcp-mux)/
            }, {
                push: "invalid",
                names: ["value"]
            }]
        };
    Object.keys(g).forEach(function(a) {
        var b = g[a];
        b.forEach(function(a) {
            a.reg || (a.reg = /(.*)/), a.format || (a.format = "%s")
        })
    });
    var h = function(a) {
            return String(Number(a)) === a ? Number(a) : a
        },
        i = function(a, b, c, d) {
            if (d && !c) b[d] = h(a[1]);
            else
                for (var e = 0; e < c.length; e += 1) null != a[e + 1] && (b[c[e]] = h(a[e + 1]))
        },
        j = function(a, b, c) {
            var d = a.name && a.names;
            a.push && !b[a.push] ? b[a.push] = [] : d && !b[a.name] && (b[a.name] = {});
            var e = a.push ? {} : d ? b[a.name] : b;
            i(c.match(a.reg), e, a.names, a.name), a.push && b[a.push].push(e)
        },
        k = RegExp.prototype.test.bind(/^([a-z])=(.*)/),
        l = /%[sdv%]/g,
        m = function(a) {
            var b = 1,
                c = arguments,
                d = c.length;
            return a.replace(l, function(a) {
                if (b >= d) return a;
                var e = c[b];
                switch (b += 1, a) {
                    case "%%":
                        return "%";
                    case "%s":
                        return String(e);
                    case "%d":
                        return Number(e);
                    case "%v":
                        return ""
                }
            })
        },
        n = function(a, b, c) {
            var d = b.format instanceof Function ? b.format(b.push ? c : c[b.name]) : b.format,
                e = [a + "=" + d];
            if (b.names)
                for (var f = 0; f < b.names.length; f += 1) {
                    var g = b.names[f];
                    e.push(b.name ? c[b.name][g] : c[b.names[f]])
                } else e.push(c[b.name]);
            return m.apply(null, e)
        },
        o = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
        p = ["i", "c", "b", "a"];
    e = function() {
        return {
            parse: function(a) {
                return b(a)
            },
            write: function(a) {
                return c(a)
            }
        }
    }, a.sdpParser = f, f.getInstance = function() {
        return d || (d = e()), d
    }
}(ATT || {}), function() {
    "use strict";

    function a() {
        return ["error", "warn", "info", "debug", "trace"]
    }

    function b() {
        return u
    }

    function c(a) {
        var b;
        for (b in q) q.hasOwnProperty(b) && q[b].setLogLevel(a)
    }

    function d() {
        var a, b = "",
            c = "",
            d = [],
            e = "",
            f = [];
        try {
            throw new Error
        } catch (g) {
            return c = 0 === g.stack.split("\n")[0].indexOf("Error") ? g.stack.split("\n")[4] : g.stack.split("\n")[3], d = c.split(":"), e = d[2], f = void 0 === e ? [] : e.split("/"), b = f[f.length - 1], void 0 !== b && b.indexOf("?") > -1 && (b = b.split("?")[0]), a = d[3], b + ":" + a
        }
    }

    function e(b, c, e) {
        var f, g, h = "",
            i = e,
            j = b;
        f = a().indexOf(b), g = t[f], (void 0 === c || "function" == typeof c) && (c = ""), "object" == typeof c && (c = JSON.stringify(c)), (void 0 === e || "function" == typeof e) && (i = ""), "object" == typeof e && (i = ":", h = JSON.stringify(e)), void 0 === console[b] && (j = "log"), console[j](g + " " + c, i, "[" + d() + "]"), 0 !== h.length && console[j](h)
    }

    function f() {
        return r
    }

    function g() {
        return s
    }

    function h(b) {
        if (void 0 === b || "string" != typeof b || 0 === b.length) throw new Error("No log level provided");
        if (-1 === a().indexOf(b)) throw new Error("Invalid log level provided");
        s = b, c(b)
    }

    function i() {
        var a, b = [];
        for (a in q) q.hasOwnProperty(a) && b.push(a);
        return b
    }

    function j() {
        var a;
        for (a in u) u.hasOwnProperty(a) && void 0 !== q[a] && q[a].setLogLevel(u[a]);
        for (a in q) q.hasOwnProperty(a) && void 0 === u[a] && q[a].setLogLevel(r)
    }

    function k(b) {
        function c() {
            return m
        }

        function d() {
            return l
        }

        function f(b) {
            if (void 0 === b || "string" != typeof b || 0 === b.length) throw new Error("No log level provided");
            if (-1 === a().indexOf(b)) throw new Error("Invalid log level provided");
            l = b
        }

        function g(b) {
            var c = a(),
                d = this.getLogLevel();
            c.indexOf("error") <= c.indexOf(d) && e("error", b)
        }

        function h(b) {
            var c = a(),
                d = this.getLogLevel();
            c.indexOf("warn") <= c.indexOf(d) && e("warn", b)
        }

        function i(b) {
            var c = a(),
                d = this.getLogLevel();
            c.indexOf("info") <= c.indexOf(d) && e("info", b)
        }

        function j(b) {
            var c = a(),
                d = this.getLogLevel();
            c.indexOf("debug") <= c.indexOf(d) && e("debug", b)
        }

        function k(b, c) {
            var d = a(),
                f = this.getLogLevel();
            d.indexOf("trace") <= d.indexOf(f) && e("trace", b, c)
        }
        var l = "",
            m = b || !1;
        this.isCustomType = c, this.setLogLevel = f, this.getLogLevel = d, this.logError = g, this.logWarning = h, this.logInfo = i, this.logDebug = j, this.logTrace = k
    }

    function l(a, b) {
        if (void 0 === a || "string" != typeof a || 0 === a.length) throw new Error("No module name provided");
        if (q[a]) throw new Error("logger is already defined");
        return q[a] = new k(b), q[a].setLogLevel(void 0 !== u[a] ? u[a] : r), q[a]
    }

    function m(a) {
        l(a, !0)
    }

    function n(a) {
        if (void 0 === a || "string" != typeof a || 0 === a.length) throw new Error("No module name provided");
        if (!q[a]) throw new Error("Invalid module name provided");
        if (q[a].isCustomType() !== !0) throw new Error("Cannot delete " + a + " logger");
        delete q[a]
    }

    function o(a) {
        if (void 0 === a || "string" != typeof a || 0 === a.length) throw new Error("No module name provided");
        if (void 0 === q[a]) throw new Error("Logger " + a + " not found");
        return q[a]
    }

    function p() {
        var a, b = {},
            c = i();
        for (a = 0; a < c.length; a += 1) b[c[a]] = o(c[a]).getLogLevel();
        return b
    }
    var q = {},
        r = "warn",
        s = r,
        t = ["[ERROR]", "[WARNING]", "[INFO]", "[DEBUG]", "[TRACE]"],
        u = {
            call: "info",
            session: "info"
        };
    ATT.logManager = function() {
        return {
            getLogLevels: a,
            getCurrentModuleLogLevels: p,
            getLoggers: i,
            getLogger: o,
            getDefaultLogLevel: f,
            getGlobalLogLevel: g,
            setGlobalLogLevel: h,
            resetLogLevels: j,
            createLogger: l,
            createCustomLogger: m,
            deleteCustomLogger: n,
            getModuleDefaults: b
        }
    }()
}(), function() {
    "use strict";

    function a() {
        function a(a, b) {
            a.callback.apply(a.context, b)
        }
        var b = {};
        return {
            getTopics: function() {
                return b
            },
            unsubscribe: function(a, c) {
                var d, e;
                if (!b.hasOwnProperty(a)) return !1;
                if ("function" != typeof c) throw new Error("Must pass in the callback you are unsubscribing");
                for (e = b[a], d = 0; d < e.length; d += 1)
                    if (e[d].callback === c) return e.splice(d, 1), 0 === e.length && delete b[a], !0;
                return !1
            },
            publish: function() {
                var c, d, e = Array.prototype.slice.call(arguments),
                    f = e.shift();
                if (!b.hasOwnProperty(f)) return !1;
                for (d = b[f], c = 0; c < d.length; c += 1) setTimeout(a.bind(null, b[f][c], e), 0);
                return !0
            },
            subscribe: function(a, c, d) {
                var e, f, g;
                if ("" === a || null === a || void 0 === a) return !1;
                if ("function" != typeof c) return !1;
                if (void 0 !== d && (null === d || "object" != typeof d)) return !1;
                for (g = {
                    context: d,
                    callback: c
                }, b.hasOwnProperty(a) || (b[a] = []), e = b[a], f = 0; f < e.length; f += 1)
                    if (c === e[f].callback) return !1;
                return b[a].push(g), !0
            }
        }
    }
    var b;
    b = typeof window.ATT, void 0 === b ? window.ATT = {
        "private": {
            factories: {}
        }
    } : void 0 === ATT["private"] && (ATT["private"] = {
        factories: {}
    }), ATT["private"].factories.createEventEmitter = a
}(), !ATT) var ATT = {};
var attUtils = null;
"object" == typeof module && module && "object" == typeof module.exports && (attUtils = {
    utils: require("./att.utils"),
    logManager: require("./att.log-manager.js")
}, module.exports = attUtils);
var RESTClient = function(a) {
    "use strict";

    function b(b) {
        b.forEach(function(b) {
            j.prototype[b] = function(c) {
                c.method = b, c.headers = h(a).extend(this.config.headers, c.headers), this.ajax(c)
            }
        })
    }
    var c, d, e = typeof window,
        f = "object" == typeof module && module && "object" == typeof module.exports,
        g = {
            "Content-Type": "application/json",
            Accept: "application/json"
        },
        h = function(a) {
            return f ? attUtils.utils.utils : a.utils
        },
        i = ATT.logManager.createLogger("RESTClient"),
        j = function(b) {
            this.config = h(a).extend({}, b), this.config.async = this.config.async || !0, this.config.success = this.config.success || function() {}, this.config.error = this.config.error || c, this.config.ontimeout = this.config.ontimeout || function(a) {
                i.logDebug(a), i.logError("Request timed out")
            }, this.config.headers = this.config.headers || g
        },
        k = function(a, b, c, d) {
            var e, f = JSON.stringify(d);
            i.logDebug("---------Request---------------"), i.logDebug(a + " " + b + " HTTP/1.1"), i.logDebug("=========headers=======");
            for (e in c) c.hasOwnProperty(e) && i.logDebug(e + ": " + c[e]);
            void 0 !== f && (i.logDebug("=========body=========="), i.logDebug(f))
        },
        l = function(a) {
            i.logDebug("---------Response--------------"), i.logDebug(a.getResponseStatus()), i.logDebug("=========headers======="), i.logDebug(a.headers), i.logDebug("=========body=========="), i.logDebug(a.responseText)
        },
        m = function(a) {
            var b, c = a.getResponseHeader("Content-Type");
            return c && 0 === c.indexOf("application/json") ? (b = JSON.parse(a.responseText), "object" == typeof b ? b : JSON.parse(b)) : ""
        },
        n = function(a, b) {
            var c = {
                getJson: function() {
                    return m(a)
                },
                getResponseHeader: function(b) {
                    return a.getResponseHeader(b)
                },
                responseText: a.responseText,
                headers: a.getAllResponseHeaders(),
                statusText: a.statusText,
                getResponseStatus: function() {
                    return a.status
                },
                getResourceURL: function() {
                    return b.method.toUpperCase() + " " + b.url
                }
            };
            return c
        },
        o = function(b) {
            var e = this,
                f = n(e, b),
                g = h(a).extend({}, f);
            l(g), e.status >= 400 && e.status <= 599 ? "function" == typeof d ? d.call(e, g) : c.call(e, g) : b.success.call(e, g)
        },
        p = function(b) {
            var c = this,
                d = n(c, b),
                e = h(a).extend({}, d);
            l(e), b.error.call(this, e)
        },
        q = function(b) {
            var c = this,
                d = n(c, b),
                e = h(a).extend({}, d);
            l(e), i.logError("Request timeout"), b.ontimeout.call(this, e)
        };
    return j.prototype.ajax = function() {
        var a = this.config,
            b = new XMLHttpRequest,
            e = null,
            f = null;
        try {
            e = a.data && JSON.stringify(a.data), void 0 !== a.timeout && (b.timeout = a.timeout), b.onload = o.bind(b, a), d = a.error, b.onerror = function() {
                if ("undefined" === a.error) throw new Error("Network error occurred in REST client.");
                p.call(this, a)
            }, b.onreadystatechange = function() {
                4 === this.readyState && 0 === this.status && "" === this.statusText && void 0 === a.ontimeout && (i.logError("Failed to complete request for resource:" + a.url), p.call(this, a))
            }, b.onabort = p.bind(b, a), b.ontimeout = q.bind(b, a), b.open(a.method, a.url, a.async);
            for (f in a.headers) a.headers.hasOwnProperty(f) && b.setRequestHeader(f, a.headers[f]);
            k(a.method, a.url, a.headers, e), b.send(e)
        } catch (g) {
            i.logError("XHR request failed, " + g), "function" == typeof d ? d.call(b, g) : c.call(b, g)
        }
    }, c = function(a) {
        throw new Error("RESTClient error handler triggered!" + a)
    }, b(["get", "post", "delete"]), j.prototype.getConfig = function() {
        return this.config
    }, "undefined" !== e && ATT && (ATT.RESTClient = j), j
}(ATT);
"object" == typeof module && module && "object" == typeof module.exports && (module.exports = RESTClient);
var attUtils = function(a) {
    "use strict";

    function b(a) {
        return null === a.match(new RegExp("[^0-9]")) ? 10 === a.length ? "tel:+" + a : 0 === a.indexOf("1") ? "tel:+" + a : 0 === a.indexOf("+") ? "tel:" + a : "sip:" + a + "@icmn.api.att.net" : a.indexOf("@") > 0 ? "sip:" + a : null
    }

    function c() {
        var a, b = navigator.userAgent,
            c = b.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        return /trident/i.test(c[1]) ? (a = /\brv[ :]+(\d+)/g.exec(b) || [], "IE " + (a[1] || "")) : "Chrome" === c[1] && (a = b.match(/\bOPR\/(\d+)/), null !== a) ? "Opera" : (c = c[2] ? [c[1], c[2]] : [navigator.appName, navigator.appVersion, "-?"], a = b.match(/version\/(\d+)/i), null !== a && c.splice(1, 1, a[1]), c[0])
    }

    function d() {
        var a, b = navigator.userAgent,
            c = b.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        return /trident/i.test(c[1]) ? (a = /\brv[ :]+(\d+)/g.exec(b) || [], "IE " + (a[1] || "")) : "Chrome" === c[1] && (a = b.match(/\bOPR\/(\d+)/), null !== a) ? a[1] : (c = c[2] ? [c[1], c[2]] : [navigator.appName, navigator.appVersion, "-?"], a = b.match(/version\/(\d+)/i), null !== a && c.splice(1, 1, a[1]), c[1])
    }
    var e = function(a, b) {
            var c;
            for (c in b) b.hasOwnProperty(c) && (b[c] instanceof Object ? a[c] = e(b[c]) : a[c] = b[c]);
            return a
        },
        f = function(a, b) {
            a["super"] = b, a.prototype = Object.create(b.prototype, {
                constructor: {
                    value: a,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            })
        },
        g = function(a, b) {
            var c = b.split("."),
                d = a;
            return c.forEach(function(a) {
                d[a] || (d[a] = {}), d = d[a]
            }), d
        };
    a.utils = {
        createNamespace: g,
        extend: e,
        inherits: f,
        createCalledPartyUri: b,
        getBrowserName: c,
        getBrowserVersion: d
    }, "object" == typeof module && module && "object" == typeof module.exports && (module.exports = a)
}(ATT);
if (!ATT) var ATT = {};
if (function(a) {
    "use strict";

    function b(a) {
        var b, c = 0;
        return b = a.replace(/m=video (\d*) RTP/g, function(a) {
            return c += 1, 1 === c ? "m=video 0 RTP" : a
        }), c = 0, b = b.replace(/a=rtcp:(\d*) IN/g, function(a) {
            return c += 1, 2 === c ? "a=rtcp:0 IN" : a
        })
    }

    function c(a, b) {
        var c = "a=" + a + "\r\n",
            d = b.indexOf(c);
        return d > 0 && (b = b.replace(c, "")), b
    }

    function d(a) {
        z.logTrace("increment sdp", a);
        var b = a.sdp.indexOf("o="),
            c = a.sdp.indexOf("s=-"),
            d = a.sdp.slice(b, c),
            e = d.split(" "),
            f = parseInt(e[2], 10) + 1,
            g = d.replace(" " + e[2].toString() + " ", " " + f.toString() + " ");
        return a.sdp = a.sdp.replace(d, g), z.logTrace("modified sdp", a), a
    }

    function e(a) {
        var b, c, d = [],
            e = ATT.sdpParser.getInstance().parse(a);
        for (z.logDebug("Parsed SDP " + e), b = 0; b < e.media.length; b += 1) c = {
            rtp: e.media[b].rtp,
            type: e.media[b].type
        }, 0 < c.rtp.length && d.push(c);
        return d
    }

    function f(a) {
        return a = a.replace(/a=mid:video\r\n/g, ""), a = a.replace(/a=mid:audio\r\n/g, ""), a = a.replace(/a=group:BUNDLE audio video\r\n/g, ""), a = a.replace(/a=group:BUNDLE audio\r\n/g, "")
    }

    function g(a) {
        return a = a.replace(/setup:passive/g, "setup:actpass"), a = a.replace(/setup:active/g, "setup:actpass")
    }

    function h(a, b) {
        return -1 === a.indexOf("m=" + b) ? !1 : !0
    }

    function i(a, b) {
        var c;
        return !1 === h(a, b) ? null : (c = a.split("m=" + b)[1], void 0 === c ? null : c)
    }

    function j(a) {
        var b;
        return !1 === h(a.sdp, a.mediaType) ? null : (b = i(a.sdp, a.mediaType).split(" ")[1], void 0 === b ? null : b)
    }

    function k(a) {
        return "string" != typeof a || 0 === a.length ? !1 : -1 === a.toLowerCase().indexOf("2 udp") ? !1 : !0
    }

    function l(a) {
        var b, c, d, e;
        return "string" != typeof a.sdp || 0 === a.sdp.length ? null : (c = i(a.sdp, a.mediaType), !1 === k(c) ? null : (b = c.split(/2 udp/i)[1], void 0 === b ? null : (d = b.split(a.ip)[1], void 0 === d ? null : e = d.split("typ")[0].trim())))
    }

    function m(a) {
        return -1 !== a.indexOf("c=IN IP4") ? a.split("c=IN IP4 ")[1].split("\r\n")[0] : null
    }

    function n(a) {
        var b, c, d, e, f;
        return d = m(a), b = j({
            sdp: a,
            mediaType: "audio"
        }), e = l({
            sdp: a,
            ip: d,
            mediaType: "audio"
        }), !0 === h(a, "video") && (c = j({
            sdp: a,
            mediaType: "video"
        }), e = l({
            sdp: a.split("m=video")[0],
            ip: d,
            mediaType: "audio"
        }), f = l({
            sdp: a,
            ip: d,
            mediaType: "video"
        })), {
            audioPort: b,
            videoPort: c,
            audioPortRTCP: e,
            videoPortRTCP: f,
            ip: d
        }
    }

    function o(a) {
        var b, c, d;
        return void 0 === a.sdpPorts.ip || null === a.sdpPorts.ip ? a.sdp : (d = a.sdp, void 0 !== a.sdpPorts.audioPort && void 0 !== a.sdpPorts.audioPortRTCP && (b = parseInt(a.sdpPorts.audioPort, 10) + 1, d = a.sdp.replace(a.sdpPorts.ip + " " + a.sdpPorts.audioPortRTCP, a.sdpPorts.ip + " " + b)), !0 === h(a.sdp, "video") && void 0 !== a.sdpPorts.videoPort && void 0 !== a.sdpPorts.videoPortRTCP && (c = parseInt(a.sdpPorts.videoPort, 10) + 1, d = d.replace(a.sdpPorts.ip + " " + a.sdpPorts.videoPortRTCP, a.sdpPorts.ip + " " + c)), d)
    }

    function p(a) {
        return -1 === a.sdp.indexOf("a=rtcp:" + a.sdpPorts.audioPort + " IN IP4") ? !1 : !0
    }

    function q(a) {
        return !1 === p(a) ? !1 : "string" != typeof a.sdpPorts.ip || "0.0.0.0" === a.sdpPorts.ip ? !1 : !1 === h(a.sdp, "audio") ? !1 : "string" != typeof a.sdpPorts.audioPort || "string" != typeof a.sdpPorts.audioPortRTCP || parseInt(a.sdpPorts.audioPortRTCP, 10) !== parseInt(a.sdpPorts.audioPort, 10) + 1 ? !1 : !0 !== h(a.sdp, "video") || "string" == typeof a.sdpPorts.videoPortRTCP && "string" == typeof a.sdpPorts.videoPort && parseInt(a.sdpPorts.videoPortRTCP, 10) === parseInt(a.sdpPorts.videoPort, 10) + 1 ? !0 : !1
    }

    function r(a) {
        var b, c, d, e;
        if (void 0 === a) throw new Error("No SDP provided");
        if (e = a, b = y.getBrowserName(), "Firefox" === b) {
            if (c = n(a), d = {
                sdp: a,
                sdpPorts: c,
                browser: b
            }, !0 === q(d) || 0 === Object.keys(c).length) return a;
            e = o(d)
        }
        return e
    }

    function s(a) {
        if (z.logDebug("sdpFilter.modifyForHoldCall"), void 0 === a) throw z.logError("Please pass the correct parameter for modifyForHoldCall"), new Error("parameter `localSdp` is undefined");
        try {
            var b = a;
            return b.sdp = b.sdp.replace(/a=sendrecv/g, "a=inactive"), b.type = "offer", b = d(b)
        } catch (c) {
            throw c
        }
    }

    function t(a) {
        if (z.logDebug("sdpFilter.modifyForResumeCall"), void 0 === a) throw z.logError("Please pass the correct parameter for modifyForResumeCall"), new Error("parameter `localSdp` is undefined");
        try {
            var b = a;
            return b.sdp = b.sdp.replace(/a=inactive/g, "a=sendrecv"), b.type = "offer", b = d(b)
        } catch (c) {
            throw c
        }
    }

    function u(a, c) {
        return c = d(c), -1 !== a.indexOf("sendrecv") && -1 !== c.sdp.indexOf("recvonly") && -1 !== a.indexOf("m=video 0 ") ? (c.sdp = b(c.sdp), c.sdp = c.sdp.replace(/a=recvonly/g, "a=sendrecv")) : -1 !== a.indexOf("sendrecv") && -1 !== c.sdp.indexOf("recvonly") && -1 !== a.indexOf("m=video 0 ") && -1 !== a.indexOf("sendonly") ? (c.sdp = b(c.sdp), c.sdp = c.sdp.replace(/a=recvonly/g, "a=sendrecv")) : -1 !== a.indexOf("sendonly") ? c.sdp = c.sdp.replace(/a=sendrecv/g, "a=recvonly") : -1 !== a.indexOf("inactive") ? c.sdp = c.sdp.replace(/a=sendonly/g, "a=inactive") : -1 !== a.indexOf("recvonly") ? c.sdp = c.sdp.replace(/a=inactive/g, "a=sendonly") : -1 !== a.indexOf("sendrecv") && (c.sdp = c.sdp.replace(/a=recvonly/g, "a=sendrecv")), c.sdp = f(c.sdp), c
    }
    var v, w, x = {},
        y = ATT.utils,
        z = ATT.logManager.createLogger("SDPFilter");
    w = function() {
        return {
            removeSDPAttribute: function(a, b) {
                return c(a, b)
            },
            getCodecfromSDP: function(a) {
                return e(a)
            },
            setupActivePassive: g,
            modifyForHoldCall: s,
            modifyForResumeCall: t,
            createManualAnswer: u,
            fixIcePorts: r,
            jslWorkarounds: f
        }
    }, a.sdpFilter = x, x.getInstance = function() {
        return v || (v = w()), v
    }
}(ATT || {}), function(a) {
    "use strict";
    var b = a.logManager.createLogger("phoneNumber"),
        c = {
            alphaLookup: {
                a: 2,
                b: 2,
                c: 2,
                d: 3,
                e: 3,
                f: 3,
                g: 4,
                h: 4,
                i: 4,
                j: 5,
                k: 5,
                l: 5,
                m: 6,
                n: 6,
                o: 6,
                p: 7,
                q: 7,
                r: 7,
                s: 7,
                t: 8,
                u: 8,
                v: 8,
                w: 9,
                x: 9,
                y: 9,
                z: 9
            },
            stringify: function(a) {
                b.logDebug("att.phonenumber: stringify"), b.logInfo("removes all the special character "), b.logTrace(a);
                var d, e = c.translate(a),
                    f = e.length,
                    g = "1" === e.charAt(0),
                    h = e.split("");
                return f > (g ? 11 : 10) ? e : !g && 4 > f ? e : (g && h.splice(0, 1), g ? f > 1 && (d = 4 - f, d = d > 0 ? d : 0, h.splice(0, 0, " ("), h.splice(4, 0, new Array(d + 1).join(" ") + ") "), f > 7 && h.splice(8, 0, "-")) : f > 7 ? (h.splice(0, 0, "("), h.splice(4, 0, ") "), h.splice(8, 0, "-")) : f > 3 && h.splice(3, 0, "-"), b.logTrace("return:" + (g ? "+1" : "") + h.join("")), (g ? "+1" : "") + h.join(""))
            },
            translate: function(a) {
                b.logDebug("att.phonenumber: translate"), b.logInfo("converts all the alphanumbers to Numbers "), b.logTrace(a);
                var d, e, f = "";
                for (d = 0; d < a.length; d += 1) e = a.charAt(d), isNaN(e) ? void 0 !== c.alphaLookup[e.toLowerCase()] && (f += c.alphaLookup[e.toLowerCase()]) : f += e;
                return b.logTrace("return:" + f), String(f)
            },
            getCallable: function(a, b) {
                var d = b || "us",
                    e = c.translate(a);
                return 10 !== e.length ? "us" === d && 11 === e.length && "1" === e.charAt(0) ? e : e : "us" === d ? "1" + e : void 0
            },
            cleanPhoneNumber: function(c) {
                b.logDebug("att.phonenumber: cleanPhoneNumber"), b.logInfo("removes special character and convert the number to a callable format"), b.logTrace(c);
                var d;
                try {
                    return -1 !== c.indexOf("@") ? c : (d = c.replace(/\s/g, ""), a.SpecialNumbers[c] ? (b.logTrace("return: " + c), c) : (d = a.phoneNumber.translate(d), b.logTrace("return: " + d), d))
                } catch (e) {
                    throw b.logTrace(e), b.logError("Error while cleaning the phonenumber"), a.errorDictionary.getSDKError(26001)
                }
            },
            formatNumber: function(c) {
                b.logDebug("att.phonenumber: formatNumber"), b.logInfo("converts the given number to a universal format"), b.logTrace(c);
                try {
                    var d = this.cleanPhoneNumber(c);
                    return d ? c.length <= 10 ? (b.logTrace("return: " + d), d) : (b.logInfo("The formated Number" + d), b.logTrace("return: " + a.phoneNumber.stringify(d)), a.phoneNumber.stringify(d)) : void b.logWarning("Phone number not formatable .")
                } catch (e) {
                    throw b.logTrace(e), b.logError("Error while formating the number "), a.errorDictionary.getSDKError(26001)
                }
            }
        };
    a.phoneNumber = c
}(ATT), !ATT) var ATT = {};
if (function(a) {
    "use strict";
    var b = {};
    b.SpecialNumbers = {
        911: !0,
        411: !0,
        611: !0,
        "*69": !0,
        "#89": !0
    }, a.SpecialNumbers = Object.freeze(b.SpecialNumbers)
}(ATT || {}), function() {
    "use strict";
    var a, b, c, d = {};
    if (a = {
        MOBILE_NUMBER: "MOBILE_NUMBER",
        VIRTUAL_NUMBER: "VIRTUAL_NUMBER",
        ACCOUNT_ID: "ACCOUNT_ID"
    }, b = {
        OUTGOING: "Outgoing",
        INCOMING: "Incoming"
    }, c = {
        INVITATION_RECEIVED: "invitation-received",
        SESSION_OPEN: "session-open",
        SESSION_MODIFIED: "session-modified",
        SESSION_TERMINATED: "session-terminated",
        MODIFICATION_RECEIVED: "mod-received",
        MODIFICATION_TERMINATED: "mod-terminated",
        TRANSFER_INITIATED: "transfer-initiated",
        TRANSFER_TERMINATED: "transfer-terminated"
    }, void 0 === ATT["private"]) throw new Error("Error exporting ATT.private.enum");
    d.USER_TYPE = Object.freeze(a), d.CALL_TYPE = Object.freeze(b), d.API_EVENT = Object.freeze(c), ATT["private"]["enum"] = d
}(), !ATT) var ATT = {};
! function() {
    "use strict";

    function a(a) {
        d.logDebug("ATT.private.config.api: configure"), d.logInfo("Configuring API..."), d.logTrace("appConfig", a);
        var b = {
            rtc_endpoint: a.api_endpoint + a.ewebrtc_uri,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return {
            createWebRTCSession: {
                method: "POST",
                url: b.rtc_endpoint + "/sessions",
                formatters: {
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("createWebRTCSession:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        },
                        "x-e911Id": function(a) {
                            return d.logDebug("createWebRTCSession:formatters:headers:x-e911Id"), d.logTrace("x-e911Id", a), a
                        },
                        "x-Arg": function(a) {
                            return d.logDebug("createWebRTCSession:formatters:headers:x-Arg"), d.logTrace("x-Arg", a), a
                        }
                    }
                },
                headers: b.headers
            },
            refreshWebRTCSession: {
                method: "PUT",
                formatters: {
                    url: function(a) {
                        return d.logDebug("refreshWebRTCSession:formatters:url"), d.logTrace("sessionId", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a), b.rtc_endpoint + "/sessions/" + a
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("refreshWebRTCSession:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        }
                    }
                },
                headers: b.headers
            },
            deleteWebRTCSession: {
                method: "DELETE",
                formatters: {
                    url: function(a) {
                        return d.logDebug("deleteWebRTCSession:formatters:url"), d.logTrace("sessionId", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a), b.rtc_endpoint + "/sessions/" + a
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("deleteWebRTCSession:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        },
                        "x-e911Id": function(a) {
                            return d.logDebug("deleteWebRTCSession:formatters:headers:x-e911Id"), d.logTrace("x-e911Id", a), a
                        }
                    }
                },
                headers: b.headers
            },
            associateTokenWithUserId: {
                method: "PUT",
                formatters: {
                    url: function(a) {
                        return d.logDebug("associateTokenWithUserId:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/userIds/" + a.userId), b.rtc_endpoint + "/userIds/" + a.userId
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("associateTokenWithUserId:formatters:headers:Authorization"), d.logTrace("oAuthToken", a), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        }
                    }
                },
                headers: {
                    Accept: "application/json"
                }
            },
            associateE911Id: {
                method: "PUT",
                formatters: {
                    url: function(a) {
                        return d.logDebug("associateE911Id:formatters:url"), d.logTrace("sessionId", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a), b.rtc_endpoint + "/sessions/" + a
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("associateE911Id:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        }
                    }
                },
                headers: b.headers
            },
            getEvents: {
                formatters: {
                    method: "GET",
                    url: function(a) {
                        return d.logDebug("getEvents:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.eventChannelUri), b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.eventChannelUri
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("getEvents:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        }
                    }
                },
                headers: {
                    Accept: "application/json"
                }
            },
            createCall: {
                method: "POST",
                formatters: {
                    url: function(a) {
                        return d.logDebug("createCall:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type), b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("createCall:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        }
                    }
                },
                headers: b.headers
            },
            modifyCall: {
                method: "PUT",
                formatters: {
                    url: function(a) {
                        return d.logDebug("modifyCall:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId), b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("modifyCall:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        },
                        options: {
                            "x-conference-action": function(a) {
                                return d.logDebug("modifyCall:formatters:headers:options:x-conference-action"), d.logTrace("x-conference-action", a), a
                            },
                            "x-calls-action": function(a) {
                                return d.logDebug("modifyCall:formatters:headers:options:x-calls-action"), d.logTrace("x-calls-action", a), a
                            }
                        }
                    }
                },
                headers: b.headers
            },
            addParticipant: {
                method: "PUT",
                formatters: {
                    url: function(a) {
                        return d.logDebug("addParticipant:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a[0] + "/conferences/" + a[1] + "/participants/" + a[2]), b.rtc_endpoint + "/sessions/" + a[0] + "/conferences/" + a[1] + "/participants/" + a[2]
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("addParticipant:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        }
                    }
                },
                headers: b.headers
            },
            removeParticipant: {
                method: "DELETE",
                formatters: {
                    url: function(a) {
                        return d.logDebug("removeParticipant:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a[0] + "/conferences/" + a[1] + "/participants/" + a[2]), b.rtc_endpoint + "/sessions/" + a[0] + "/conferences/" + a[1] + "/participants/" + a[2]
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("removeParticipant:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        }
                    }
                },
                headers: b.headers
            },
            acceptCallModifications: {
                method: "PUT",
                formatters: {
                    url: function(a) {
                        return d.logDebug("acceptCallModifications:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId), b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("acceptCallModifications:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        },
                        "x-modId": function(a) {
                            return d.logDebug("acceptCallModifications:formatters:headers:x-modId"), d.logTrace("x-modId", a), a
                        }
                    }
                },
                headers: ATT.utils.extend({
                    "x-calls-action": "accept-call-mod"
                }, b.headers)
            },
            acceptConferenceModifications: {
                method: "PUT",
                formatters: {
                    url: function(a) {
                        return d.logDebug("acceptConferenceModifications:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId), b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("acceptConferenceModifications:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        },
                        "x-mod-Id": function(a) {
                            return d.logDebug("acceptConferenceModifications:formatters:headers:x-mod-Id"), d.logTrace("x-mod-Id", a), a
                        }
                    }
                },
                headers: ATT.utils.extend({
                    "x-conference-action": "accept-media-mod"
                }, b.headers)
            },
            deleteCall: {
                method: "DELETE",
                formatters: {
                    url: function(a) {
                        return d.logDebug("deleteCall:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId), b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("deleteCall:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        },
                        "x-delete-reason": function(a) {
                            return d.logDebug("deleteCall:formatters:headers:x-delete-reason"), d.logTrace("x-delete-reason", a), a
                        }
                    }
                },
                headers: b.headers
            },
            transferCall: {
                method: "PUT",
                formatters: {
                    url: function(a) {
                        return d.logDebug("transferCall:formatters:url"), d.logTrace("params", a), d.logTrace("url", b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId), b.rtc_endpoint + "/sessions/" + a.sessionId + "/" + a.type + "/" + a.callId
                    },
                    headers: {
                        Authorization: function(a) {
                            return d.logDebug("transferCall:formatters:headers:Authorization"), d.logTrace("Authorization", "Bearer " + a), "Bearer " + a
                        },
                        "x-transferTargetCallId": function(a) {
                            return d.logDebug("transferCall:formatters:headers:x-transferTargetCallId"), d.logTrace("x-transferTargetCallId", a), a
                        }
                    }
                },
                headers: ATT.utils.extend({
                    "x-calls-action": "initiate-call-transfer"
                }, b.headers)
            }
        }
    }

    function b() {
        d.logDebug("ATT.private.config.api: getAPIConfiguration");
        var b = c.app.getAppConfiguration();
        return d.logTrace("currentConfig", b), a(b)
    }
    var c, d = ATT.logManager.createLogger("configAPI");
    if (void 0 === ATT["private"] || void 0 === ATT["private"].config) throw d.logError("Error exporting ATT.private.config.api"), new Error("Error exporting ATT.private.config.api");
    c = ATT["private"].config, c.api = {
        getAPIConfiguration: b
    }
}(),
function() {
    "use strict";

    function a(a) {
        n.logDebug("ATT.private.config.app: setAppConfiguration"), n.logInfo("Setting app configuration"), n.logTrace("options", a), j = a.api_endpoint || j, k = a.ewebrtc_uri || k
    }

    function b() {
        return n.logDebug("ATT.private.config.app: getAppConfiguration"), n.logInfo("Getting app configuration"), f = {
            api_endpoint: j,
            ewebrtc_uri: k,
            eventChannelType: m
        }, n.logTrace("appConfig", f), f
    }

    function c() {
        return g
    }

    function d() {
        return h
    }

    function e() {
        return i
    }
    var f, g, h, i = {
            supported: [{
                name: "Chrome",
                version: {
                    min: 38
                }
            }, {
                name: "Firefox",
                version: {
                    min: 33,
                    max: 33
                }
            }],
            not_certified: [{
                name: "Chrome",
                version: {
                    min: 32,
                    max: 37
                }
            }, {
                name: "Firefox",
                version: {
                    min: 28,
                    max: 32
                }
            }, {
                name: "Opera"
            }]
        },
        j = "https://api.att.com",
        k = "/RTC/v1",
        l = {
            WebSockets: "WebSockets",
            LongPolling: "LongPolling"
        },
        m = l.LongPolling,
        n = ATT.logManager.createLogger("configApp");
    if (g = {
        iceServers: [{
            url: "STUN:12.194.159.4"
        }, {
            url: "STUN:12.194.159.7"
        }, {
            url: "STUN:12.194.159.10"
        }, {
            url: "STUN:12.194.194.4"
        }, {
            url: "STUN:12.194.194.7"
        }, {
            url: "STUN:12.194.194.10"
        }],
        iceTransports: "all",
        ipv6: !1
    }, h = ATT.utils.extend({}, g), n.logDebug("Loading ATT.private.config.app..."), void 0 === ATT["private"] || void 0 === ATT["private"].config) throw new Error("Error exporting ATT.private.config.app");
    ATT["private"].config.app = {
        getAppConfiguration: b,
        setAppConfiguration: a,
        getBrowserSupport: e,
        getDefaultPcConfig: c,
        getCurrentPcConfig: d
    }
}(),
function() {
    "use strict";

    function a(a) {
        return Object.freeze(a), a
    }
    var b = [{
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: "0000",
        ErrorMessage: "Error Code is not defined in error dictionary",
        Cause: "Error Code is not defined in error dictionary",
        Resolution: "Add the error object in error dictionary"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "configure",
        ErrorCode: "0001",
        ErrorMessage: "Unable to configure the endpoint for SDK. Please ensure that correct config key is used to configure the endpoint",
        Cause: "Configuration key is not found",
        Resolution: "Please check appConfig module for correct config key"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: "0002",
        ErrorMessage: "Unable to perform requested operation. Please ensure that the application is hosted on the provisioned domain.",
        Cause: "CORS configuration",
        Resolution: "Please ensure that the application is hosted on the provisioned domain"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: "0003",
        ErrorMessage: "Request timed out",
        Cause: "Network failure",
        Resolution: "Please check the logs and network connectivity and try again"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "Phone",
        ErrorCode: "1000",
        ErrorMessage: "Missing input parameter",
        Cause: "One or more of the input parameters are empty",
        Resolution: "Please check the values for input parameters"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "Phone",
        ErrorCode: "1001",
        ErrorMessage: "Missing local video stream",
        Cause: "Input parameter localVideoElementID is missing",
        Resolution: "Please check the values for localVideoElementID"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "Phone",
        ErrorCode: "1002",
        ErrorMessage: "Missing remote video stream",
        Cause: "Input parameter remoteVideoElementID is missing",
        Resolution: "Please check the values for remoteVideoElementID"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "Phone",
        ErrorCode: "1003",
        ErrorMessage: "Invalid media type",
        Cause: "Invalid media constraints",
        Resolution: "Please provide use valid Media constraints attributes"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "Phone",
        ErrorCode: "1004",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "Phone",
        ErrorCode: "1005",
        ErrorMessage: "Cannot join conference. An active call is already going on",
        Cause: "Invalid operation",
        Resolution: "Please end the active call before joining the incoming conference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "Phone",
        ErrorCode: "1006",
        ErrorMessage: "Cannot accept incoming call. An active conference is already going on",
        Cause: "Invalid operation",
        Resolution: "Please end the active conference before joining the incoming call"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "Phone",
        ErrorCode: "1007",
        ErrorMessage: "Cannot accept incoming conference. An active conference is already going on",
        Cause: "Invalid operation",
        Resolution: "Please end the active conference before joining the incoming conference"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: "2000",
        ErrorMessage: "Invalid user type",
        Cause: "Unsupported user type",
        Resolution: "Supported user types are Mobile Number, Virtual Number, Account ID"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: "2001",
        ErrorMessage: "Missing input parameter",
        Cause: "Access token & E911 ID is required",
        Resolution: "User type, Access token, E911 ID are mandatory fields for Mobile Number & Virtual Number user types"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: "2002",
        ErrorMessage: "Mandatory fields can not be empty",
        Cause: "One of the Mandatory Parameters is empty",
        Resolution: "Please check the values for input parameters"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: "2003",
        ErrorMessage: "Invalid input parameter",
        Cause: "Invalid parameter",
        Resolution: "For Account ID users E911 is not required"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: "2004",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: "2005",
        ErrorMessage: "User already logged in",
        Cause: "Duplicate operation",
        Resolution: "Login should be called only once per session"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "logout",
        ErrorCode: "3000",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "logout",
        ErrorCode: "3001",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid Logout operation",
        Resolution: "None"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "logout",
        ErrorCode: "3002",
        ErrorMessage: "User already logged out",
        Cause: "Duplicate operation",
        Resolution: "Logout should be called only once per session"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4000",
        ErrorMessage: "Invalid input parameter",
        Cause: "Invalid phone number",
        Resolution: "Please provide a valid phone number"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4001",
        ErrorMessage: "Invalid input parameter",
        Cause: "Invalid SIP URI",
        Resolution: "Please provide valid SIP URI"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4002",
        ErrorMessage: "Invalid media type",
        Cause: "Invalid media constraints",
        Resolution: "Please provide use valid Media constraints attributes"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4003",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4004",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking dial"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4005",
        ErrorMessage: "Can not make second call. Please put the current call on hold before making second call.",
        Cause: "Invalid operation",
        Resolution: "Please ensure that current call is on hold before making second call"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4006",
        ErrorMessage: "parameter `localMedia` is not defined",
        Cause: "localMedia is not defined",
        Resolution: "Please include `localMedia` parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4007",
        ErrorMessage: "parameter `remoteMedia` is not defined",
        Cause: "remoteMedia is not defined",
        Resolution: "Please include `remoteMedia` parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4008",
        ErrorMessage: "parameter `destination` is not defined",
        Cause: "destination is not defined",
        Resolution: "Please include `destination` parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4009",
        ErrorMessage: "options parameter is not defined",
        Cause: "options are not defined",
        Resolution: "You must include the options parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "dial",
        ErrorCode: "4010",
        ErrorMessage: "Cannot dial another call when there is a call in dialing state",
        Cause: "Trying to dial another call when a call is still in dialing state",
        Resolution: "The dialling (pending) call must be connected before you can proceed with another call"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "answer",
        ErrorCode: "5000",
        ErrorMessage: "Answer failed- No incoming call",
        Cause: "No incoming call",
        Resolution: "No incoming call"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "answer",
        ErrorCode: "5001",
        ErrorMessage: "Invalid media type",
        Cause: "Invalid media constraints",
        Resolution: "Please provide use valid Media constraints attributes"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "answer",
        ErrorCode: "5002",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "answer",
        ErrorCode: "5003",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking answer"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "answer",
        ErrorCode: "5004",
        ErrorMessage: "Mandatory fields can not be empty",
        Cause: "One of the Mandatory Parameters is empty",
        Resolution: "Please check the values for input parameters"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "answer",
        ErrorCode: "5005",
        ErrorMessage: "Invalid Action parameter",
        Cause: "Action can only be `hold` or `end`",
        Resolution: "Please provide a valid action (hold or end)"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "hangup",
        ErrorCode: "6000",
        ErrorMessage: "Hangup failed- Call is not in progress",
        Cause: "Can not hangup before the call is established",
        Resolution: "Please use cancel call, or allow call to be established before trying to hang-up."
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "hangup",
        ErrorCode: "6001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "hold",
        ErrorCode: "7000",
        ErrorMessage: "Hold failed- Call is not in progress",
        Cause: "Cannot hold. There is no active call in progress.",
        Resolution: "Please ensure an active call is in progress before trying to put the call on Hold."
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "hold",
        ErrorCode: "7001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "resume",
        ErrorCode: "8000",
        ErrorMessage: "Resume failed- Call is not in progress",
        Cause: "There is no active call in progress.",
        Resolution: "Please ensure an active call is in progress."
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "resume",
        ErrorCode: "8001",
        ErrorMessage: "Resume failed- An invalid operation or call is not on hold",
        Cause: "Invalid operation",
        Resolution: "Please confirm that an active call is on Hold before trying to Resume."
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "resume",
        ErrorCode: "8002",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "mute",
        ErrorCode: "9000",
        ErrorMessage: "Mute failed- Call is not in progress",
        Cause: "No media stream",
        Resolution: "Please confirm that an active call is in progress."
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "mute",
        ErrorCode: "9001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "mute",
        ErrorCode: "9002",
        ErrorMessage: "Mute failed- Already muted",
        Cause: "Duplicate operation",
        Resolution: ""
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "unmute",
        ErrorCode: "10000",
        ErrorMessage: "Unmute failed- No media stream",
        Cause: "No media stream",
        Resolution: "Please confirm that an active call is in progress."
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "unmute",
        ErrorCode: "10001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "unmute",
        ErrorCode: "10002",
        ErrorMessage: "Unmute failed- Already Unmuted",
        Cause: "Duplicate operation",
        Resolution: ""
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "cancel",
        ErrorCode: "11000",
        ErrorMessage: "Cancel failed-Call has not been initiated",
        Cause: "No call to cancel in progress",
        Resolution: "Please invoke dial before invoking cancel"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "cancel",
        ErrorCode: "11001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "reject",
        ErrorCode: "12000",
        ErrorMessage: "Reject failed-Call has not been initiated",
        Cause: "No call to reject",
        Resolution: "Reject can be performed only on incoming call"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "reject",
        ErrorCode: "12001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "13000",
        ErrorMessage: "Unable to send information about this party",
        Cause: "PeerConnection Create offer failed",
        Resolution: "Please check the logs on the console"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "13001",
        ErrorMessage: "Unable to acknowledge other party",
        Cause: "PeerConnection Create answer failed",
        Resolution: "Please check the logs on the console"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "13002",
        ErrorMessage: "Local media description not accepted by connection",
        Cause: "PeerConnection setLocalDescription failed",
        Resolution: "Please check the logs on the console"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "13003",
        ErrorMessage: "Other party media description not accepted by connection",
        Cause: "PeerConnection setRemoteDescription failed",
        Resolution: "Please check the logs on the console"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "13004",
        ErrorMessage: "Negotiation for connectivity failed",
        Cause: "PeerConnection addIceCandidate failed",
        Resolution: "Please check the logs on the console"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "13005",
        ErrorMessage: "onUserMediaError",
        Cause: "Failed to get the UserMedia",
        Resolution: "Please enable Media for the browser "
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "14000",
        ErrorMessage: "Permission denied to access audio/video",
        Cause: "User denied permission",
        Resolution: "User may intentionally have denied permission, please retry the requested operation"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "14001",
        ErrorMessage: "Unsupported browser-unable to get audio/video",
        Cause: "Unsupported browser",
        Resolution: "The browser does not support Enhanced WebRTC, please use Enhanced WebRTC supported browser"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "14002",
        ErrorMessage: "Invalid input for media request",
        Cause: "Invalid media constraints",
        Resolution: "Please check the media constraints"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "15000",
        ErrorMessage: "Cannot interpret other party's state",
        Cause: "Unable to Setup Event Interceptor. Please contact support.",
        Resolution: "Please contact support"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "15001",
        ErrorMessage: "Event Channel unable to shutdown gracefully",
        Cause: "Unable to shut down event channel. Please logout and login again.",
        Resolution: "Please login again"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: "15002",
        ErrorMessage: "Event Channel got shutdown unexpectedly",
        Cause: "Event Channel stopped. Please logout and login again.",
        Resolution: "Please login again"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "associateE911Id",
        ErrorCode: "17000",
        ErrorMessage: "e911Id parameter missing",
        Cause: "Once or more required input parameter(s) are missing",
        Resolution: "Please pass E911Id as a parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "associateE911Id",
        ErrorCode: "17001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "associateE911Id",
        ErrorCode: "17002",
        ErrorMessage: "Could not update E911 Id, E911 Id could be updated only for ongoing session",
        Cause: "Precondition failed",
        Resolution: "E911 Id can be updated only for ongoing session, Please login and then update E911 Id if necessary"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "startConference",
        ErrorCode: "18000",
        ErrorMessage: "parameters missing",
        Cause: "no parameter passed ",
        Resolution: "Please pass parameters to startConference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "startConference",
        ErrorCode: "18001",
        ErrorMessage: "Invalid localMedia passed ",
        Cause: "localMedia parameter missing",
        Resolution: "Please pass localMedia as a parameter for start conference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "startConference",
        ErrorCode: "18002",
        ErrorMessage: "Invalid remoteMedia passed",
        Cause: "remoteMedia parameter missing",
        Resolution: "Please pass remoteMedia as a parameter for start conference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "startConference",
        ErrorCode: "18003",
        ErrorMessage: "Invalid mediatype passed ",
        Cause: "mediatype parameter missing",
        Resolution: "please pass mediatype as a parameter for start conference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "startConference",
        ErrorCode: "18004",
        ErrorMessage: "Internal error occurred",
        Cause: "onUserMediaError",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "startConference",
        ErrorCode: "18005",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "startConference",
        ErrorCode: "18006",
        ErrorMessage: "Cannot make second conference when first in progress",
        Cause: "conference already exists",
        Resolution: "Please End your current Conference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "startConference",
        ErrorCode: "18007",
        ErrorMessage: "User not login to make conference",
        Cause: "User not logged In",
        Resolution: "Please login before you make a conference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipant",
        ErrorCode: "19000",
        ErrorMessage: "participant parameter missing",
        Cause: "One or more required input parameter(s) are missing",
        Resolution: "Please provide participant parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipant",
        ErrorCode: "19001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "joinConference",
        ErrorCode: "20000",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "joinConference",
        ErrorCode: "20001",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking join conference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "joinConference",
        ErrorCode: "20002",
        ErrorMessage: "No conference invite",
        Cause: "Invalid operation",
        Resolution: "Cannot join conference before receiving an invite"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "rejectConference",
        ErrorCode: "22000",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "rejectConference",
        ErrorCode: "22001",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking reject conference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "rejectConference",
        ErrorCode: "22002",
        ErrorMessage: "No conference invite",
        Cause: "Invalid operation",
        Resolution: "Cannot reject conference before receiving an invite"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "getParticipants",
        ErrorCode: "21000",
        ErrorMessage: "Conference not initiated",
        Cause: "Invalid operation",
        Resolution: "Please invoke conference first before invoking getParticipants"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "getParticipants",
        ErrorCode: "21001",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "getParticipants",
        ErrorCode: "21002",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking getParticipants"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "endConference",
        ErrorCode: "23000",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "endConference",
        ErrorCode: "23001",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking endConference"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "endConference",
        ErrorCode: "23002",
        ErrorMessage: "endConference failed - Conference is not in progress",
        Cause: "Cannot end Conference before the conference is established",
        Resolution: "Allow conference to be established before trying to end"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipants",
        ErrorCode: "24000",
        ErrorMessage: "participants parameter missing",
        Cause: "One or more required input parameter(s) are missing",
        Resolution: "Please provide participants parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipants",
        ErrorCode: "24001",
        ErrorMessage: "User is not logged in",
        Cause: "One or more required input parameter(s) are not correct",
        Resolution: "Please provide participants parameter of type array"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipants",
        ErrorCode: "24002",
        ErrorMessage: "participants parameter incorrect",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking addParticipants"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipants",
        ErrorCode: "24003",
        ErrorMessage: "Conference not initiated",
        Cause: "Invalid operation",
        Resolution: "Please invoke conference first before invoking addParticipants"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipants",
        ErrorCode: "24004",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipants",
        ErrorCode: "24005",
        ErrorMessage: "Cannot invite existing participant",
        Cause: "Invalid operation",
        Resolution: "Please invite new user"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipants",
        ErrorCode: "24006",
        ErrorMessage: "Invalid input parameter",
        Cause: "Invalid phone number",
        Resolution: "Please provide valid 10 digit phone number"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addParticipants",
        ErrorCode: "24007",
        ErrorMessage: "Invalid input parameter",
        Cause: "Invalid SIP URI",
        Resolution: "Please provide valid SIP URI"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "removeParticipant",
        ErrorCode: "25000",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking removeParticipant"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "removeParticipant",
        ErrorCode: "25001",
        ErrorMessage: "removeParticipant failed - Conference is not in progress",
        Cause: "Cannot remove participant before the conference is established",
        Resolution: "Allow conference to be established before trying to remove participant"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "removeParticipant",
        ErrorCode: "25002",
        ErrorMessage: "participant parameter missing",
        Cause: "One or more required input parameter(s) are missing",
        Resolution: "Please provide participant parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "removeParticipant",
        ErrorCode: "25003",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "CleanNumber",
        ErrorCode: "26001",
        ErrorMessage: "Number Invalid",
        Cause: "Invalid PhoneNumber passed",
        Resolution: "Please check the logs and pass a valid phone number"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27000",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27001",
        ErrorMessage: "Invalid options provided",
        Cause: "Input options are not provided",
        Resolution: "Please include the required parameters"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27002",
        ErrorMessage: "parameter `localMedia` is not defined",
        Cause: "LocalMedia is not defined",
        Resolution: "Please include localMedia parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27003",
        ErrorMessage: "parameter `remoteMedia` is not defined",
        Cause: "remoteMedia is not defined",
        Resolution: "Please include remoteMedia parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27004",
        ErrorMessage: "parameter `destination` is not defined",
        Cause: "destination is not defined",
        Resolution: "Please include destination parameter"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27005",
        ErrorMessage: "Invalid input parameter",
        Cause: "Invalid phone number",
        Resolution: "Please provide valid phone number"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27006",
        ErrorMessage: "Invalid input parameter",
        Cause: "Invalid SIP URI",
        Resolution: "Please provide valid SIP URI"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27007",
        ErrorMessage: "Invalid media type",
        Cause: "Invalid media constraints",
        Resolution: "Please provide use valid Media constraints attributes"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27008",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking dial"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27009",
        ErrorMessage: "Can not make second call. There is no first call in progress.",
        Cause: "Invalid operation",
        Resolution: "Please ensure that there is an existing call in progress before making second call"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "addCall",
        ErrorCode: "27010",
        ErrorMessage: "Cannot make a third call.",
        Cause: "Trying to make a third call.",
        Resolution: "Please end one of the calls."
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "move",
        ErrorCode: "28000",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking move"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "move",
        ErrorCode: "28001",
        ErrorMessage: "Move failed - call is not in progress",
        Cause: "Cannot move. There is no active call in progress.",
        Resolution: "Please ensure an active call is in progress before trying to move the call"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "move",
        ErrorCode: "28002",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "transfer",
        ErrorCode: "29000",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "transfer",
        ErrorCode: "29001",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking transfer"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "transfer",
        ErrorCode: "29002",
        ErrorMessage: "transfer failed - call is not in progress",
        Cause: "Cannot transfer. There is no active call in progress.",
        Resolution: "Please ensure an active call is in progress before trying to transfer the call"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "transfer",
        ErrorCode: "29003",
        ErrorMessage: "Cannot make a third call",
        Cause: "Trying to make a third call",
        Resolution: "Please end one of the calls"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "transfer",
        ErrorCode: "29004",
        ErrorMessage: "Transfer failed - There is only one call in progress",
        Cause: "invalid Options",
        Resolution: "Please establish two calls before invoking transfer"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "switch",
        ErrorCode: "30000",
        ErrorMessage: "Internal error occurred",
        Cause: "Uncaught error",
        Resolution: "Please check the logs and contact support if needed"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "switch",
        ErrorCode: "30001",
        ErrorMessage: "User is not logged in",
        Cause: "Invalid operation",
        Resolution: "Please login first before invoking switch"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "switch",
        ErrorCode: "30002",
        ErrorMessage: "Switch failed - call is not in progress",
        Cause: "Cannot switch. There is no active call in progress.",
        Resolution: "Please ensure an active call is in progress before trying to invoke switch"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "switch",
        ErrorCode: "30003",
        ErrorMessage: "Switch failed - only one call is in progress",
        Cause: "Trying to invoke switch when only one call is established",
        Resolution: "Please create two calls before invoking switch"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "setIceServers",
        ErrorCode: "40000",
        ErrorMessage: "Invalid iceServers Array passed",
        Cause: "The iceServers parameter passed is not a valid Array of ice servers ",
        Resolution: "Please verify the input to be a valid ice server array with uris"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "setIceTransport",
        ErrorCode: "50000",
        ErrorMessage: "Invalid ice Transport parameters passed",
        Cause: "The ice transport parameter passed is not a valid string",
        Resolution: "Please provide a valid string as an input for ice Transport"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "setIceTransport",
        ErrorCode: "50001",
        ErrorMessage: "Passed and invalid values other then  'none','all' or 'relay' for iceTransport",
        Cause: "The ice transport parameter passed has invalid values",
        Resolution: "Please pass 'none','all' or 'relay' as values to iceTransport"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "setIpv6",
        ErrorCode: "60000",
        ErrorMessage: "Passed a invalid ipv6 parameter. ",
        Cause: "The ipv6 parameter passed is not a boolean or invalid ",
        Resolution: "Please pass a boolean value to setIpv6 method"
    }];
    if (void 0 === window.ATT.utils) throw new Error("Cannot export SDK Errors into ATT.utils.ErrorStore.SDKErrors, ATT.utils namespace is undefined...\n ATT: " + JSON.stringify(window.ATT));
    window.ATT.utils.ErrorStore = {}, window.ATT.utils.ErrorStore.SDKErrors = {
        getAllSDKErrors: function() {
            var c, d, e = {};
            for (c = 0; c < b.length; c += 1) d = b[c].ErrorCode, e[d] = b[c];
            return a(e)
        }
    }
}(),
function() {
    "use strict";
    var a = [{
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: 2500,
        ErrorMessage: "System error occurred",
        PossibleCauses: "System error occurred",
        PossibleResolution: "Use the explanation to find the reason for failure.",
        APIError: "SVC0001: A service error has occurred. Error code is <error_explanation>",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 400,
        MessageId: "SVC0001"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: 2501,
        ErrorMessage: "Mandatory parameter is missing in the Request.",
        PossibleCauses: "Mandatory parameter is missing in the request.",
        PossibleResolution: "The parameter name is suggested in the error text. …message part contains the missing parameter name.",
        APIError: "SVC0002 - Invalid input value for message part <part_name>",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 400,
        MessageId: "SVC0002"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: 2502,
        ErrorMessage: "Invalid values provided for a parameter in the Request.",
        PossibleCauses: "Invalid values are passed in the Request.",
        PossibleResolution: "Pass the valid values as suggested in the error response.",
        APIError: "SVC0003 - Invalid input value for message part <part_name>, valid values are <part_values>",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 400,
        MessageId: "SVC0003"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: 2504,
        ErrorMessage: "E911 not supported for non-telephone users",
        PossibleCauses: "E911 Id is not required a parameter for this user type (account id)",
        PossibleResolution: "Please don’t pass E911 id to login for account id users",
        APIError: "SVC8510:E911 not supported for non-telephone users",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 400,
        MessageId: "SVC8510"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: 2505,
        ErrorMessage: "Valid e911Id is mandatory for mobile number or virtual number",
        PossibleCauses: "x-e911Id is missing in the request. x-e911Id is invalid.",
        PossibleResolution: "e911Id should be retrieved using E911 API and appropriately passed in the Create Session Request.",
        APIError: "SVC8511:Valid e911Id is mandatory for <part_value>",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 400,
        MessageId: "SVC8511"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: 2506,
        ErrorMessage: "Access token not associated with virtual number or account id",
        PossibleCauses: "Access token not assigned to virtual number or account id.",
        PossibleResolution: "Call associate token operation before create session for virtual number or account id scenario.",
        APIError: "SVC8512:Unassigned token associate token to virtual number or account id",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 400,
        MessageId: "SVC8512"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: 2507,
        ErrorMessage: "Token in use.",
        PossibleCauses: "A session was already created with the access token",
        PossibleResolution: "In case user abruptly closed the application, called to expire the token and receive new token.",
        APIError: "SVC8513:Token in use.",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 400,
        MessageId: "SVC8513"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: 2508,
        ErrorMessage: "Access token is invalid.",
        PossibleCauses: "Access Token is incorrect or invalid. Access token is not authorized for the Enhanced WebRTC scope.",
        PossibleResolution: "Re-authenticate and retrieve the correct access token.",
        APIError: "POL0001:A policy error occurred.",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 401,
        MessageId: "POL0001"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: 2509,
        ErrorMessage: "Invalid token",
        PossibleCauses: "Access Token is incorrect or invalid.",
        PossibleResolution: "Re-Authenticate and retrieve the correct access token for Enhanced WebRTC",
        APIError: "POL0002:Privacy verification failed for address <address> request is refused",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 403,
        MessageId: "POL0002"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: 2510,
        ErrorMessage: "Not implemented",
        PossibleCauses: "Reserved for future use",
        PossibleResolution: "Reserved for future use",
        APIError: "POL0003:Too many addresses specified in Message part",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 403,
        MessageId: "POL0003"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "*",
        ErrorCode: 2511,
        ErrorMessage: "User has not been provisioned for Enhanced WebRTC",
        PossibleCauses: "User has not been provisioned for Enhanced WebRTC service",
        PossibleResolution: "End user needs to provide consent to get provisioned.",
        APIError: "POL1009:User has not been provisioned for %1",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 403,
        MessageId: "POL1009"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "login",
        ErrorCode: 2512,
        ErrorMessage: "Number of Session exceeds the allowed limit.",
        PossibleCauses: "For virtual number and account id users: Since virtual number is assigned to a specific user.Max number of sessions is defined by the network.",
        PossibleResolution: "For virtual number and account id scenario, contact Administrator.",
        APIError: "POL1100:Max number of session exceeded allowed limit %1",
        ResourceMethod: "POST /RTC/v1/sessions",
        HttpStatusCode: 403,
        MessageId: "POL1100"
    }, {
        JSObject: "ATT.rtc",
        JSMethod: "logout",
        ErrorCode: 3507,
        ErrorMessage: "Session Id is not associated with the Access Token passed in the request.",
        PossibleCauses: "Access Token that was passed in the Request is not mapped to the Session Id.",
        PossibleResolution: "Use the same Access Token that was initially passed in.",
        APIError: "POL1102:Session Id not associated with the token",
        ResourceMethod: "DELETE /RTC/v1/sessions/{sessionid}",
        HttpStatusCode: 403,
        MessageId: "POL1102"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "answer",
        ErrorCode: 5504,
        ErrorMessage: "Duplicate Request",
        PossibleCauses: "A media modification is in progress for the callId.",
        PossibleResolution: "Complete the In-Progress Media modification before initiating another request.",
        APIError: "SVC8501: Call <callid> in progress",
        ResourceMethod: "PUT /RTC/v1/sessions/{sessionid}/calls/{callid}",
        HttpStatusCode: 409,
        MessageId: "SVC8501"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "hold",
        ErrorCode: 7508,
        ErrorMessage: "Duplicate Request",
        PossibleCauses: "A media modification is in progress for the callId.",
        PossibleResolution: "Complete the In-Progress Media modification before initiating another request.",
        APIError: "SVC8501: Call <callid> in progress",
        ResourceMethod: "PUT /RTC/v1/sessions/{sessionid}/calls/{callid}",
        HttpStatusCode: 409,
        MessageId: "SVC8501"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "resume",
        ErrorCode: 8508,
        ErrorMessage: "Duplicate request",
        PossibleCauses: "A media modification is in progress for the callId.",
        PossibleResolution: "Complete the In-Progress Media modification before initiating another request.",
        APIError: "SVC8501: Call <callid> in progress",
        ResourceMethod: "PUT /RTC/v1/sessions/{sessionid}/calls/{callid}",
        HttpStatusCode: 409,
        MessageId: "SVC8501"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "createE911Id",
        ErrorCode: 16503,
        ErrorMessage: "Address provided by the end user is not geo codable.",
        PossibleCauses: "The address provided is unreachable.",
        PossibleResolution: "Correct the portion of address as per the error text and retry.",
        APIError: "SVC0015: Address is not valid address for E911 routing.Reason",
        ResourceMethod: "POST emergencyServices/v1/e911Location",
        HttpStatusCode: 400,
        MessageId: "SVC0015"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "createE911Id",
        ErrorCode: 16504,
        ErrorMessage: "The address provided is not present in the System.",
        PossibleCauses: "The address provided is not present in the System.",
        PossibleResolution: "Confirm the address by setting isAddressConfirmed to true and retry.",
        APIError: "SVC0016: Address Confirmation Required ",
        ResourceMethod: "POST emergencyServices/v1/e911Location",
        HttpStatusCode: 400,
        MessageId: "SVC0016"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "createE911Id",
        ErrorCode: 16505,
        ErrorMessage: "System is unavailable to process the request.",
        PossibleCauses: "System is unavailable to process the request.",
        PossibleResolution: "Please try again later.",
        APIError: "SVC0017: NENA provider system is not available.",
        ResourceMethod: "POST emergencyServices/v1/e911Location",
        HttpStatusCode: 400,
        MessageId: "SVC0017"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "createE911Id",
        ErrorCode: 16506,
        ErrorMessage: "System is available but could not process the request.",
        PossibleCauses: "System is available but could not process the request.",
        PossibleResolution: "Please contact system administrator.",
        APIError: "SVC0018: NENA provider system error",
        ResourceMethod: "POST emergencyServices/v1/e911Location",
        HttpStatusCode: 400,
        MessageId: "SVC0018"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "createE911Id",
        ErrorCode: 16507,
        ErrorMessage: "Access token is invalid.",
        PossibleCauses: "1. Access Token is incorrect or in valid.?2. Access token is not authorized for the Enhanced WebRTC scope.",
        PossibleResolution: "Re-Authenticate and retrieve the correct access token.",
        APIError: "POL0001: A policy error occurred. For example, rate…it error, authentication and authorization errors",
        ResourceMethod: "POST emergencyServices/v1/e911Location",
        HttpStatusCode: 401,
        MessageId: "POL0001"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "createE911Id",
        ErrorCode: 16508,
        ErrorMessage: "Invalid token",
        PossibleCauses: "Access Token is incorrect or in valid.",
        PossibleResolution: "Re-Authenticate and retrieve the correct access token for Enhanced WebRTC",
        APIError: "POL0002: Privacy verification failed for address <address> request is refused",
        ResourceMethod: "POST emergencyServices/v1/e911Location",
        HttpStatusCode: 403,
        MessageId: "POL0002"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "createE911Id",
        ErrorCode: 16509,
        ErrorMessage: "Not implemented",
        PossibleCauses: "Reserved for future use",
        PossibleResolution: "Reserved for future use",
        APIError: "POL0003: Too many addresses specified in Message part",
        ResourceMethod: "POST emergencyServices/v1/e911Location",
        HttpStatusCode: 403,
        MessageId: "POL0003"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "createE911Id",
        ErrorCode: 16511,
        ErrorMessage: "System error occurred",
        PossibleCauses: "System error occurred",
        PossibleResolution: "Use the explanation to find the reason for failure.",
        APIError: "SVC0001: A service error has occurred. Error code is <error_explanation>",
        ResourceMethod: "POST emergencyServices/v1/e911Location",
        HttpStatusCode: 400,
        MessageId: "SVC0001"
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: 500,
        ErrorMessage: "<method name> failed - Unable to complete requested operation",
        PossibleCauses: "System error occurred",
        PossibleResolution: "Use the explanation to find the reason for failure.",
        APIError: "Populated from API response if available",
        ResourceMethod: "METHOD: Resource URL",
        HttpStatusCode: 500,
        MessageId: ""
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: 502,
        ErrorMessage: "<method name> failed - Unable to complete requested operation",
        PossibleCauses: "Please look into API Error",
        PossibleResolution: "Please look into API Error",
        APIError: "Populated from API response if available",
        ResourceMethod: "METHOD: Resource URL",
        HttpStatusCode: 502,
        MessageId: ""
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: 503,
        ErrorMessage: "<method name> failed - Unable to complete requested operation",
        PossibleCauses: "Bad Gateway",
        PossibleResolution: "Please look into API Error",
        APIError: "Populated from API response if available",
        ResourceMethod: "METHOD: Resource URL",
        HttpStatusCode: 503,
        MessageId: ""
    }, {
        JSObject: "ATT.rtc.Phone",
        JSMethod: "*",
        ErrorCode: 504,
        ErrorMessage: "<method name> failed - Unable to complete requested operation",
        PossibleCauses: "Service Unavailable",
        PossibleResolution: "Please look into API Error",
        APIError: "Populated from API response if available",
        ResourceMethod: "METHOD: Resource URL",
        HttpStatusCode: 504,
        MessageId: ""
    }];
    if (void 0 === window.ATT.utils.ErrorStore) throw new Error("Cannot export SDK Errors into ATT.utils.ErrorStore.APIErrors, ATT.utils.ErrorStore namespace is undefined.\n ATT: " + JSON.stringify(window.ATT));
    window.ATT.utils.ErrorStore.APIErrors = {
        getAllAPIErrors: function() {
            return a
        }
    }
}(),
function() {
    "use strict";

    function a(a, b) {
        function c(a) {
            return a.formatError = function() {
                var b = a.JSObject + "-" + a.JSMethod + "-" + a.ErrorCode + "-" + a.ErrorMessage + "-" + a.PossibleCauses + "-" + a.PossibleResolution + "-" + a.APIError + "-" + a.ResourceMethod + "-" + a.HttpStatusCode + "-" + a.MessageId;
                return b
            }, a
        }

        function d(a) {
            return a.getId = function() {
                var b = a.ErrorCode;
                return b
            }, a
        }

        function e(a) {
            return a.getAPIErrorByMethodStatusMsgId = function() {
                var b = a.JSMethod + a.HttpStatusCode + a.MessageId;
                return b
            }, a
        }
        var f, g = {
            JSObject: "",
            JSMethod: "",
            ErrorCode: "",
            ErrorMessage: "",
            PossibleCauses: "",
            PossibleResolution: "",
            APIError: "",
            ResourceMethod: "",
            HttpStatusCode: "",
            MessageId: ""
        };
        return f = Object.create(g), f = b.extend(f, a), f = c(f), f = d(f), f = e(f)
    }

    function b(b, c) {
        var d = ATT.utils,
            e = null,
            f = 0,
            g = [],
            h = c.length;
        for (f = 0; h > f; f += 1) e = a(c[f], d), g[e.getId()] = e, g[e.getAPIErrorByMethodStatusMsgId()] = e;
        return {
            createError: function(b) {
                return a(b, d)
            },
            getSDKError: function(a) {
                return b[a]
            },
            getError: function(a) {
                return g[a]
            },
            getAPIError: function(a, b, c) {
                var d = g[a + b + c];
                return d || (d = g["*" + b + c], d && (d.JSMethod = a)), d
            },
            getDefaultError: function(b) {
                return a(b, d)
            }
        }
    }
    var c;
    c = typeof module, "undefined" !== c && module.exports && (module.exports = b);
    try {
        window.ATT.utils.createErrorDictionary = b
    } catch (d) {
        throw new Error("Error while exporting ATT.errorDictionary.\n ATT = ", JSON.stringify(window.ATT) + "Original Message: " + d.message)
    }
}(),
function() {
    "use strict";

    function a(a) {
        c.logDebug("ATT.private.error: parseAPIErrorResponse"), c.logInfo("Parses the error response and checks for Type"), c.logTrace(a);
        var b, d = a.getJson(),
            e = {};
        return d.RequestError ? (d.RequestError.ServiceException ? e = {
            APIError: d.RequestError.ServiceException.MessageId + ":" + d.RequestError.ServiceException.Text + ",Variables=" + d.RequestError.ServiceException.Variables,
            MessageId: d.RequestError.ServiceException.MessageId
        } : d.RequestError.PolicyException ? e = {
            APIError: d.RequestError.PolicyException.MessageId + ":" + d.RequestError.PolicyException.Text + ",Variables=" + d.RequestError.PolicyException.Variables,
            MessageId: d.RequestError.PolicyException.MessageId
        } : d.RequestError.Exception && (e = {
            APIError: (d.RequestError.Exception.MessageId || "") + ":" + d.RequestError.Exception.Text + ",Variables=" + d.RequestError.Exception.Variables || "",
            MessageId: d.RequestError.Exception.MessageId
        }), e.ResourceMethod = a.getResourceURL(), e.HttpStatusCode = a.getResponseStatus(), e.APIError || (e.APIError = a.responseText, e.MessageId = "", c.logError("Unable to parse API Error. Response is empty :" + a)), c.logTrace("return: " + e), e) : (a.getResponseStatus() >= 500 ? (b = "" !== a.getJson() ? JSON.stringify(a.getJson()) : a.responseText, e = ATT.errorDictionary.getAPIError("*", a.getResponseStatus(), ""), e.APIError = b, c.logError("Service Unavailable"), c.logError(a), c.logError(e)) : (e = {
            APIError: a.responseText
        }, c.logError(a), c.logError(e)), e.ResourceMethod = a.getResourceURL(), e.HttpStatusCode = a.getResponseStatus(), c.logTrace("return:" + e), e)
    }

    function b(a, b, d, e) {
        c.logDebug("ATT.private.error: createAPIErrorCode"), c.logInfo("Parses the error response and checks for Type"), c.logTrace("methodName: " + d), c.logTrace("moduleId: " + e), c.logTrace("raw error", a);
        var f, g;
        return void 0 !== a.HttpStatusCode ? g = a : void 0 !== a.errorDetail.HttpStatusCode && (g = a.errorDetail), d = d || "GeneralOperation", e = e || "RTC", 0 !== g.HttpStatusCode ? (f = ATT.errorDictionary.getAPIError(d, g.HttpStatusCode, g.MessageId), void 0 !== f && (f.APIError = g.APIError, f.HttpStatusCode = g.HttpStatusCode, f.MessageId = g.MessageId, f.ResourceMethod = g.ResourceMethod)) : f = g, f || (c.logError("Error not found in Error dictionary "), c.logError(a), f = ATT.errorDictionary.getDefaultError({
            JSObject: b,
            ErrorCode: e + "-UNKNOWN",
            JSMethod: d,
            HttpStatusCode: a.HttpStatusCode || "Unknown",
            ErrorMessage: d + " failed",
            APIError: g.APIError || a.responseText,
            PossibleCauses: "Please look into APIError",
            PossibleResolution: "Please look into APIError",
            MessageId: g.MessageId || "",
            ResourceMethod: g.ResourceMethod || a.getResourceURL()
        }), c.logError("Generating Missing error response:" + f)), f
    }
    var c = ATT.logManager.createLogger("privateError");
    if (c.logDebug("Initializing error module"), void 0 === ATT["private"]) throw new Error("Error exporting ATT.private.error");
    ATT["private"].error = {
        parseAPIErrorResponse: a,
        createAPIErrorCode: b
    }
}(),
function() {
    "use strict";

    function a(a) {
        if (c.logDebug("ATT.rtc: configure"), c.logTrace("options", a), c.logDebug("Configuring the SDK"), void 0 === a || 0 === Object.keys(a).length) throw new Error("No options provided");
        b.app.setAppConfiguration(a)
    }
    var b = ATT["private"].config,
        c = ATT.logManager.createLogger("rtc");
    c.logDebug("Loading att.rtc..."), ATT.rtc.configure = a
}(),
function() {
    "use strict";

    function a() {
        if (f.logDebug("ATT.rtc: hasWebRTC"), f.logInfo("Checking if Enhanced WebRTC is supported"), "function" == typeof navigator.mozGetUserMedia || "function" == typeof navigator.webkitGetUserMedia || "function" == typeof navigator.getUserMedia) {
            var a, b, c = e.app.getBrowserSupport(),
                d = g.getBrowserName(),
                h = g.getBrowserVersion(),
                i = !1,
                j = !1;
            if (f.logInfo("Browser: " + d), f.logInfo("Version: " + h), 0 < c.supported.length && 0 < c.not_certified.length) {
                if (0 <= c.supported.length)
                    for (b = 0; b < c.supported.length; b += 1) a = c.supported[b], d === a.name && (i = !0, void 0 !== a.version && (void 0 !== a.version.min && a.version.min > Number.parseInt(h) && (i = !1), void 0 !== a.version.max && a.version.max < Number.parseInt(h) && (i = !1)));
                if (i) return f.logInfo("Browser supported"), "Supported";
                if (0 <= c.not_certified.length)
                    for (b = 0; b < c.not_certified.length; b += 1) a = c.not_certified[b], d === a.name && (j = !0, void 0 !== a.version && (void 0 !== a.version.min && a.version.min > Number.parseInt(h) && (j = !1), void 0 !== a.version.max && a.version.max < Number.parseInt(h) && (j = !1)));
                if (j) return f.logWarning("Browser not certified"), "Not Certified"
            }
        }
        return f.logError("Browser not supported"), "Not Supported"
    }

    function b() {
        return "undefined" !== navigator ? window.isNavigatorOnline() ? !0 : !1 : void 0
    }

    function c() {
        return window.navigator.onLine
    }

    function d() {
        return e.app.getBrowserSupport()
    }
    var e = ATT["private"].config,
        f = ATT.logManager.createLogger("browser"),
        g = ATT.utils;
    if (f.logDebug("Loading att.browser..."), window.isNavigatorOnline = c, void 0 === ATT.browser) throw new Error("Error exporting ATT.browser methods");
    ATT.browser.hasWebRTC = a, ATT.browser.isNetworkConnected = b, ATT.browser.getBrowserSupport = d
}(),
function() {
    "use strict";

    function a(a) {
        function f(a, b) {
            e.logDebug("ATT.private.resourceManager: createRESTConfiguration"), e.logInfo("Creating REST configuration..."), e.logTrace("operationConfig", a), e.logTrace("options", b);
            var d, f, g, h, i, j, k, l;
            if (d = c.extend({}, a), f = a.formatters || {}, g = Object.keys(f).length, f && g > 0) {
                if (void 0 === b.params || g !== Object.keys(b.params).length) throw e.logError("Params passed in must match number of formatters"), e.logTrace("formatters", f), e.logTrace("params", b.params), new Error("Params passed in must match number of formatters.");
                if (f.method && !b.params.method) throw e.logError("Missing method parameter for the method formatter."), new Error("Missing method parameter for the method formatter.");
                if (f.url && !b.params.url) throw e.logError("Missing URL parameter for the URL formatter."), new Error("Missing URL parameter for the URL formatter.");
                if (f.headers && Object.keys(b.params.headers).length !== Object.keys(a.formatters.headers).length) throw e.logError("Header formatters in APIConfigs do not match header parameters provided."), new Error("Header formatters in APIConfigs do not match the header parameters being passed in.");
                if ("string" == typeof f.method && (d.method = b.params.method || a.formatters.method, e.logInfo("updated restConfig method"), e.logTrace("restConfig.method", d.method)), "function" == typeof f.url && (d.url = a.formatters.url(b.params.url), e.logInfo("updated restConfig url"), e.logTrace("restConfig.url", d.url)), "object" == typeof f.headers && Object.keys(f.headers).length > 0) {
                    l = {}, e.logInfo("Configuring request headers...");
                    for (h in b.params.headers)
                        if (b.params.headers.hasOwnProperty(h)) {
                            if ("options" === h && "object" == typeof a.formatters.headers[h]) {
                                if (0 === Object.keys(b.params.headers[h]).length) throw e.logError("Options for header not passed in. Cannot construct request"), new Error("Options for header not passed in. Cannot construct request");
                                k = Object.keys(b.params.headers[h])[0], i = a.formatters.headers[h][k], j = b.params.headers[h][k], h = k
                            } else i = a.formatters.headers[h], j = b.params.headers[h];
                            l[h] = i(j), e.logTrace(h, l[h])
                        }
                    d.headers = ATT.utils.extend({}, d.headers), d.headers = ATT.utils.extend(d.headers, l), e.logTrace("restConfig.headers", d.headers)
                }
            }
            return b.data && (d.data = b.data), e.logTrace("restConfig", d), d
        }

        function g(a) {
            function c(c, f, g) {
                e.logDebug("restOperation");
                var h;
                b = ATT.errorDictionary, a.success = c, a.error = function(a) {
                    0 === a.getResponseStatus() && "" === a.responseText ? (a.errorDetail = b.getSDKError("0003"), a.errorDetail.HttpStatusCode = a.getResponseStatus(), a.errorDetail.ResourceMethod = a.getResourceURL(), f.call(this, a.errorDetail)) : (a.errorDetail = d.parseAPIErrorResponse(a), f.call(this, a.errorDetail))
                }, a.ontimeout = function() {
                    var c = {};
                    c.errorDetail = b.getSDKError("0003"), c.errorDetail.HttpStatusCode = 0, c.errorDetail.ResourceMethod = a.url, g ? g.call(this, c.errorDetail) : f.call(this, c.errorDetail)
                }, h = new ATT.RESTClient(a), h.ajax()
            }
            return e.logDebug("ATT.private.resourceManager: createRESTOperation"), e.logInfo("Creating REST Operation..."), e.logTrace("restConfig", a), c
        }

        function h(a, b) {
            e.logDebug("ATT.private.resourceManager: getOperation"), e.logTrace("operationName", a), e.logTrace("operationOpts", b);
            var c, d, h, i;
            if (i = k.getAPIConfiguration(), c = i[a], void 0 === c) throw new Error("Operation not found.");
            if (void 0 === b) throw new Error("No options found.");
            return d = f(c, b), h = g(d)
        }

        function i(a, b) {
            if (e.logDebug("ATT.private.resourceManager: doOperation"), e.logTrace("operationName", a), e.logTrace("operationConfig", b), void 0 === a || 0 === a.length) throw e.logError("no operation name provided"), new Error("Must specify an operation name.");
            if (void 0 === b || 0 === Object.keys(b).length) throw new Error("No options found.");
            if (void 0 === b.success) throw new Error("No `success` callback passed.");
            if ("function" != typeof b.success) throw new Error("`success` callback has to be a function.");
            if (void 0 === b.error) throw new Error("No `error` callback passed.");
            if ("function" != typeof b.error) throw new Error("`error` callback has to be a function.");
            try {
                var c = h(a, b);
                e.logInfo("About to perform operation " + a), c(b.success, b.error, b.ontimeout)
            } catch (d) {
                throw e.logError("Error performing operation: " + a), e.logTrace(d), d
            }
        }

        function j() {
            return e.logDebug("ATT.private.resourceManager: getRestOperationsConfig"), k.getAPIConfiguration()
        }
        e.logDebug("ATT.private.factories: createResourceManager"), e.logInfo("Creating resource manager..."), e.logTrace("apiConfig", a);
        var k;
        if (void 0 === a || 0 === Object.keys(a).length) throw new Error("No API configuration passed");
        if (void 0 === a.getAPIConfiguration) throw new Error("No `getAPIConfiguration` method found.");
        return k = a, {
            doOperation: i,
            getRestOperationsConfig: j
        }
    }
    var b, c = ATT.utils,
        d = ATT["private"].error,
        e = ATT.logManager.createLogger("resourceManager");
    if (e.logDebug("Loading att.private.resource-manager..."), void 0 === ATT["private"].factories) throw new Error("Error exporting `createResourceManager`");
    ATT["private"].factories.createResourceManager = a
}(),
function() {
    "use strict";

    function a(a) {
        function e(a) {
            if (b.logDebug("ATT.utils.event-channel: processMessages"), b.logInfo("Processing events..."), b.logTrace("messages", a), m = JSON.parse(t ? a.responseText : a.data), b.logTrace("eventData", m), m.events) {
                b.logInfo("Publish events individually");
                var c, d = m.events.eventList;
                for (c in d) d.hasOwnProperty(c) && (b.logTrace("eventObject", d[c].eventObject), q.publish("api-event", d[c].eventObject))
            }
        }

        function f() {
            b.logDebug("ATT.utils.event-channel: stopListening"), b.logInfo("Stop listening to event channel"), s = !1
        }

        function g(a, c) {
            if (b.logDebug("ATT.utils.event-channel: on"), b.logInfo("Subscribing to event-channel event " + a), "api-event" !== a && "channel-error" !== a) throw b.logError("Event not defined"), new Error("Event not defined");
            if ("function" != typeof c) throw b.logError("Handler is not a function"), new Error("Handler is not a function");
            q.unsubscribe(a, c), q.subscribe(a, c, this)
        }

        function h(c, d) {
            b.logDebug("ATT.utils.event-channel: retry"), b.logInfo("Retry polling ..."), b.logTrace("config", c), b.logTrace("error", d), 204 !== d.HttpStatusCode ? (b.logInfo("Response code was: " + d.HttpStatusCode), b.logInfo("Re-polling...")) : 0 === d.HttpStatusCode ? (b.logInfo("Request timed out"), b.logInfo("Re-polling...")) : (b.logInfo("Response code was: " + d.HttpStatusCode), b.logInfo("Re-polling...")), setTimeout(function() {
                b.logInfo("Continue polling..."), a.resourceManager.doOperation(w, r)
            }, 0)
        }

        function i(c) {
            b.logDebug("ATT.utils.event-channel: startListening"), b.logInfo("Start listening to event channel..."), b.logTrace("config", c), s = !0, r = {
                params: {
                    method: t ? "GET" : "POST",
                    url: {
                        sessionId: a.sessionId,
                        eventChannelUri: t ? "events" : "websockets"
                    },
                    headers: {
                        Authorization: a.accessToken
                    }
                },
                success: n.bind(this, c),
                error: o.bind(this, c),
                ontimeout: p.bind(this, c)
            }, a.resourceManager.doOperation(w, r)
        }
        b.logDebug("ATT.utils.event-channel: createEventChannel"), b.logInfo("Creating event channel..."), b.logTrace("channelConfig", a);
        var j, k, l, m, n, o, p, q, r = {},
            s = !1,
            t = !0,
            u = 2e3,
            v = 3e5,
            w = "getEvents";
        if (void 0 === a || 0 === Object.keys(a).length) throw b.logError("No options"), new Error("No options");
        if (void 0 === a.accessToken) throw b.logError("No Access Token"), new Error("No Access Token");
        if (void 0 === a.sessionId) throw b.logError("NO Session Id"), new Error("No Session Id");
        if (void 0 === a.resourceManager) throw b.logError("No Resource Manager"), new Error("No Resource Manager");
        return void 0 !== a.interval && (b.logInfo("Configuring interval"), b.logTrace("interval", a.interval), u = a.interval), void 0 !== a.maxPollingTime && (b.logInfo("Configuring maximum polling time"), b.logTrace("maxPollingTime", a.maxPollingTime), v = a.maxPollingTime), "WebSockets" === a.channelType && (b.logInfo("Setting long polling to false for WebSockets"), b.logTrace("channelType", a.channelType), t = !1), q = c.createEventEmitter(), b.logTrace("event-channel / operationConfig: "), b.logTrace(r), n = function(c, d) {
            return b.logDebug("createEventChannel: onSuccess"), b.logInfo("Successfully created event channel"), b.logTrace("response", d), "function" == typeof c.success && (b.logInfo("Successfully got response from event channel"), c.success("Successfully got response from event channel")), s ? t ? (b.logInfo("Processing messages..."), 200 === d.getResponseStatus() && (e(d), b.logInfo("Messages processed, Re-polling..."), b.logTrace("response", d)), void setTimeout(function() {
                b.logInfo("Continue polling..."), a.resourceManager.doOperation(w, r)
            }, 0)) : (l = d.getResponseHeader("location"), b.logInfo("Channel sockets"), b.logTrace("locationForSocket", l), void(void 0 === k && l && (k = new WebSocket(l), k.onmessage = function(a) {
                b.logDebug("createEventChannel: onMessage"), b.logInfo("Message received"), b.logTrace("message", a), e(a)
            }))) : void b.logInfo("Not processing response because event channel is not running")
        }, o = function(a, c) {
            if (s) {
                if (b.logDebug("createEventChannel: onError"), b.logError("Error creating event channel"), b.logTrace("config", a), b.logInfo("Re-polling..."), u = 2 * u, u > v) return b.logInfo("Stopping event channel, maximum polling time reached"), b.logTrace("interval", u), b.logTrace("maxPollingTime", v), f(), void q.publish("channel-error", d.createAPIErrorCode(c, "ATT.rtc.Phone", "events", "RTC"));
                h(a, c)
            } else b.logError("Error running event channel"), b.logTrace("error", c)
        }, p = function(a, c) {
            b.logDebug("createEventChannel: onTimeOut"), b.logTrace("config", a), b.logTrace("error", c), s && (b.logError("Request timed out"), h(a, c))
        }, j = {
            isListening: function() {
                return s
            },
            startListening: i,
            stopListening: f,
            on: g
        }
    }
    var b = ATT.logManager.createLogger("eventChannel"),
        c = ATT["private"].factories,
        d = ATT["private"].error;
    if (void 0 === ATT["private"].factories) throw b.logError("Error exporting `createEventChannel`"), new Error("Error exporting `createEventChannel`");
    ATT["private"].factories.createEventChannel = a
}(),
function() {
    "use strict";

    function a(a) {
        function e(a) {
            d.logDebug("ATT.event-manager: processEvent"), d.logInfo("Processing the events coming from event channel");
            var b, e, f, g;
            if (!a) return void d.logError("Not able to consume null event...");
            switch (d.logDebug("Consumed event from event channel:"), void 0 !== a.type && d.logTrace("type:", a.type), void 0 !== a.from && d.logTrace("from:", a.from), void 0 !== a.state && d.logTrace("state:", a.state), void 0 !== a.sdp && d.logTrace("Event SDP", a.sdp), e = "calls" === a.type ? "call" : "conference", f = a.resourceURL.split("/")[4], g = a.resourceURL.split("/")[6], (a.state === c.API_EVENT.SESSION_OPEN || a.state === c.API_EVENT.SESSION_MODIFIED) && a.sdp && -1 !== a.sdp.indexOf("m=video 0") && -1 === a.sdp.indexOf("a=inactive") && (-1 === a.sdp.indexOf("c=IN IP4 0.0.0.0") && (a.sdp = a.sdp.replace("sendrecv", "inactive")), a.sdp = a.sdp.replace("c=IN IP4 0.0.0.0", "a=inactive")), d.logTrace("Event state", a.state), a.state) {
                case c.API_EVENT.INVITATION_RECEIVED:
                    b = ATT.sdpFilter.getInstance().getCodecfromSDP(a.sdp), n.publish(c.API_EVENT.INVITATION_RECEIVED + ":" + f, {
                        type: e,
                        id: g,
                        from: a.from,
                        mediaType: 1 === b.length ? "audio" : "video",
                        sdp: a.sdp
                    });
                    break;
                case c.API_EVENT.MODIFICATION_RECEIVED:
                    n.publish(c.API_EVENT.MODIFICATION_RECEIVED + ":" + g, {
                        id: g,
                        remoteSdp: a.sdp,
                        modificationId: a.modId
                    });
                    break;
                case c.API_EVENT.MODIFICATION_TERMINATED:
                    n.publish(c.API_EVENT.MODIFICATION_TERMINATED + ":" + g, {
                        id: g,
                        type: e,
                        remoteSdp: a.sdp,
                        modificationId: a.modId,
                        reason: a.reason,
                        from: a.from
                    });
                    break;
                case c.API_EVENT.SESSION_OPEN:
                    void 0 !== a.sdp && (b = ATT.sdpFilter.getInstance().getCodecfromSDP(a.sdp)), n.publish(c.API_EVENT.SESSION_OPEN + ":" + g, {
                        type: e,
                        id: g,
                        remoteSdp: a.sdp,
                        mediaType: b ? 1 === b.length ? "audio" : "video" : null,
                        codec: b || null,
                        provisionalSdp: a.provisionalSDP
                    });
                    break;
                case c.API_EVENT.SESSION_MODIFIED:
                    n.publish(c.API_EVENT.SESSION_MODIFIED + ":" + g, {
                        type: e,
                        id: g,
                        remoteSdp: a.sdp
                    });
                    break;
                case c.API_EVENT.TRANSFER_INITIATED:
                    n.publish(c.API_EVENT.TRANSFER_INITIATED + ":" + g, {
                        type: e,
                        id: g,
                        from: a.from,
                        transferToCallId: a.transferToCallId
                    });
                    break;
                case c.API_EVENT.TRANSFER_TERMINATED:
                    n.publish(c.API_EVENT.TRANSFER_TERMINATED + ":" + g, {
                        type: e,
                        id: g,
                        from: a.from,
                        transferToCallId: a.transferToCallId,
                        reason: a.reason
                    });
                    break;
                case c.API_EVENT.SESSION_TERMINATED:
                    n.publish(c.API_EVENT.SESSION_TERMINATED + ":" + g, {
                        type: e,
                        id: g,
                        from: a.from,
                        reason: a.reason
                    });
                    break;
                default:
                    d.logError("Unrecognized event state: " + a.state)
            }
        }

        function f(a) {
            d.logDebug("ATT.event-manager: setupEventChannel"), d.logInfo("Setting up the event channel"), d.logTrace(a);
            var c = {
                accessToken: a.token,
                sessionId: a.sessionId,
                publisher: n,
                resourceManager: m,
                channelType: k
            };
            l = b.createEventChannel(c), l && (d.logInfo("Event channel up and running"), l.on("api-event", function(a) {
                e(a)
            }), l.on("channel-error", function(b) {
                a.onError(b)
            }), d.logInfo("Subscribed to api-event from event channel"), l.startListening({
                success: function(a) {
                    d.logDebug("startListening: success"), d.logInfo("successfully started listening"), d.logTrace(a)
                },
                error: a.onError
            })), n.publish("listening")
        }

        function g() {
            d.logDebug("ATT.event-manager: stop"), d.logInfo("stop listening"), l && (l.stopListening(), d.logInfo("Event channel shutdown successfully")), n.publish("stop-listening")
        }

        function h(a, b) {
            d.logDebug("ATT.event-manager: off"), d.logInfo("Unsubscribing from event-manager event: " + a), n.unsubscribe(a, b)
        }

        function i(a, b) {
            if (d.logDebug("ATT.rtc.RTCManager: on"), d.logInfo("Subscribing to event-manager event: " + a), "listening" !== a && "stop-listening" !== a && a.indexOf(c.API_EVENT.INVITATION_RECEIVED + ":") < 0 && a.indexOf(c.API_EVENT.SESSION_OPEN + ":") < 0 && a.indexOf(c.API_EVENT.SESSION_MODIFIED + ":") < 0 && a.indexOf(c.API_EVENT.MODIFICATION_RECEIVED + ":") < 0 && a.indexOf(c.API_EVENT.MODIFICATION_TERMINATED + ":") < 0 && a.indexOf(c.API_EVENT.SESSION_TERMINATED + ":") < 0 && a.indexOf(c.API_EVENT.TRANSFER_INITIATED) < 0 && a.indexOf(c.API_EVENT.TRANSFER_TERMINATED) < 0) throw d.logError("Event " + a + " not found"), new Error("Event " + a + " not found");
            n.unsubscribe(a, b), n.subscribe(a, b)
        }

        function j(a) {
            if (d.logDebug("ATT.event-manager: setup"), d.logInfo("Setting up the event channel"), d.logTrace(a), void 0 === a) throw d.logError("Options not defined"), new Error("Options not defined");
            if (void 0 === a.sessionId) throw d.logError("Session id is not defined"), new Error("Session id is not defined");
            if (void 0 === a.token) throw d.logError("Token not defined"), new Error("Token not defined");
            f(a)
        }
        d.logDebug("ATT.event-manager: createEventManager"), d.logTrace(a);
        var k, l, m, n;
        if (d.logDebug("createEventManager"), void 0 === a || 0 === Object.keys(a).length) throw d.logError("Invalid options"), new Error("Invalid options");
        if (void 0 === a.resourceManager) throw d.logError("Must pass `options.resourceManager`"), new Error("Must pass `options.resourceManager`");
        if (void 0 === a.eventChannelType) throw d.logError("Must pass `options.eventChannelType`"), new Error("Must pass `options.eventChannelType`");
        return k = a.eventChannelType, m = a.resourceManager, n = b.createEventEmitter(), {
            on: i,
            off: h,
            setup: j,
            stop: g
        }
    }
    var b = ATT["private"].factories,
        c = ATT["private"]["enum"],
        d = ATT.logManager.createLogger("eventManager");
    if (void 0 === ATT["private"].factories) throw new Error("Error exporting createEventManager");
    ATT["private"].factories.createEventManager = a
}(),
function() {
    "use strict";

    function a(a) {
        function d(a) {
            f.logDebug("ATT.private.RTCManager: extractSessionInformation"), f.logTrace("responseObject", a);
            var b = null,
                c = null;
            if (a && (a.getResponseHeader("Location") && (b = a.getResponseHeader("Location").split("/")[4]), a.getResponseHeader("x-expires") && (c = a.getResponseHeader("x-expires"), c = Number(c), c = isNaN(c) ? 0 : 1e3 * c)), !b) throw "Failed to retrieve session id";
            return {
                sessionId: b,
                timeout: c
            }
        }

        function h(a, b) {
            f.logDebug("ATT.private.RTCManager: on"), f.logInfo("Subscribing to RTCmanager event: " + a), B.on(a, b)
        }

        function i(a, b) {
            f.logDebug("ATT.private.RTCManager: off"), f.logInfo("Unsubscribing from RTCmanager event: " + a), B.off(a, b)
        }

        function j(a) {
            if (f.logDebug("ATT.private.RTCManager: refreshSession"), f.logTrace("refreshSessionOpts", a), void 0 === a || 0 === Object.keys(a).length) throw new Error("Invalid options");
            if (void 0 === a.sessionId) throw new Error("No session ID passed");
            if (void 0 === a.token) throw new Error("No token passed");
            if (void 0 === a.success) throw new Error("No `success` callback passed");
            if ("function" != typeof a.success) throw new Error("`success` callback has to be a function");
            if (void 0 === a.error) throw new Error("No `error` callback passed");
            if ("function" != typeof a.error) throw new Error("`error` callback has to be a function");
            f.logInfo("Calling operation refreshWebRTCSession to refresh session..."), C.doOperation("refreshWebRTCSession", {
                success: function(b) {
                    f.logDebug("doOperation(refreshWebRTCSession): success"), f.logInfo("Successfully completed operation refreshWebRTCSession");
                    var c = parseInt(b.getResponseHeader("x-expires"), 10);
                    f.logTrace("Session timeout", c), a.success({
                        timeout: (1e3 * c).toString()
                    })
                },
                error: function(b) {
                    f.logDebug("doOperation(refreshWebRTCSession): error"), f.logError("Error during operation refreshWebRTCSession"), f.logTrace(b), a.onError(c.createAPIErrorCode(b, "ATT.rtc.Phone", "refreshSession", "RTC"))
                },
                params: {
                    url: [a.sessionId],
                    headers: {
                        Authorization: a.token
                    }
                }
            })
        }

        function k(a) {
            if (f.logDebug("ATT.private.RTCManager: connectSession"), f.logTrace("connectSessionOpts", a), void 0 === a) throw new Error("No options defined.");
            if (void 0 === a.token) throw new Error("No token defined.");
            if (void 0 === a.onSessionConnected) throw new Error("Callback onSessionConnected not defined.");
            if (void 0 === a.onSessionReady) throw new Error("Callback onSessionReady not defined.");
            if (void 0 === a.onError) throw new Error("Callback onError not defined.");
            var b = function(b) {
                var c, e;
                try {
                    f.logDebug("doOperation(createWebRTCSession): success"), f.logInfo("Successfully created web rtc session"), e = d(b), a.onSessionConnected(e), c = function() {
                        f.logInfo("listening@eventManager"), a.onSessionReady({
                            sessionId: e.sessionId
                        }), B.off("listening", c)
                    }, B.on("listening", c), f.logInfo("Trying to setup the event manager..."), B.setup({
                        sessionId: e.sessionId,
                        token: a.token,
                        onError: function(b) {
                            f.logDebug("eventManager.setup: onError"), f.logError("There was an error setting up the eventManager"), f.logTrace(b), a.onError(b)
                        }
                    })
                } catch (g) {
                    f.logError("Error during connectionSession"), f.logTrace(g), a.onError({
                        error: ATT.errorDictionary.getSDKError("2004")
                    })
                }
            };
            f.logInfo("Attempting to create enhanced webrtc session"), C.doOperation("createWebRTCSession", {
                data: {
                    session: {
                        mediaType: "dtls-srtp",
                        ice: "true",
                        services: ["ip_voice_call", "ip_video_call"]
                    }
                },
                params: {
                    headers: {
                        Authorization: a.token,
                        "x-e911Id": a.e911Id || "",
                        "x-Arg": "ClientSDK=WebRTCTestAppJavascript1"
                    }
                },
                success: b,
                error: function(b) {
                    f.logError("createWebRTCSession: error"), f.logTrace(b), a.onError(c.createAPIErrorCode(b, "ATT.rtc.Phone", "login", "RTC"))
                }
            })
        }

        function l(a) {
            if (f.logDebug("ATT.private.RTCManager: disconnectSession"), f.logTrace("disconnectSessionOpts", a), void 0 === a) throw new Error("No options defined.");
            if (void 0 === a.sessionId) throw new Error("No session id defined.");
            if (void 0 === a.token) throw new Error("No token defined.");
            if (void 0 === a.onSessionDisconnected) throw new Error("Callback onSessionDisconnected not defined.");
            f.logInfo("Attempting to stop event manager..."), B.stop(), f.logInfo("Attempting to delete enhanced webrtc session"), C.doOperation("deleteWebRTCSession", {
                params: {
                    url: [a.sessionId],
                    headers: {
                        Authorization: a.token,
                        "x-e911Id": a.e911Id
                    }
                },
                success: function() {
                    f.logDebug("doOperation(deleteWebRTCSession): error"), f.logInfo("Successfully deleted enhanced webrtc session"), a.onSessionDisconnected()
                },
                error: function(b) {
                    f.logDebug("doOperation(deleteWebRTCSession): error"), f.logError("Error during deleteWebRTCSession"), f.logTrace(b), a.onError(c.createAPIErrorCode(b, "ATT.rtc.Phone", "logout", "RTC"))
                }
            })
        }

        function m(a) {
            f.logDebug("ATT.private.RTCManager: connectCall"), f.logTrace("connectCallOpts", a);
            var b, c, d, e, h;
            if (void 0 === a) throw new Error("No options provided");
            if (void 0 === a.breed) throw new Error("No call breed provided");
            if ("call" === a.breed && void 0 === a.peer) throw new Error("No peer provided");
            if (void 0 === a.sessionId) throw new Error("No session id provided");
            if (void 0 === a.token) throw new Error("No token provided");
            if (void 0 === a.description) throw new Error("No description provided");
            if (void 0 === a.onSuccess && "function" != typeof a.onSuccess) throw new Error("No success callback provided");
            if (void 0 === a.onError && "function" != typeof a.onError) throw new Error("No error callback provided");
            return void 0 === a.callId ? (h = "call" === a.breed ? {
                call: {
                    calledParty: g.createCalledPartyUri(a.peer),
                    sdp: a.description.sdp
                }
            } : {
                conference: {
                    sdp: a.description.sdp
                }
            }, d = {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: a.breed + "s"
                    },
                    headers: {
                        Authorization: a.token
                    }
                },
                data: h,
                success: function(c) {
                    f.logDebug("doOperation(createCall): success"), f.logInfo("Success during creating call/conference"), f.logTrace("response", c), b = {
                        id: c.getResponseHeader("Location").split("/")[6],
                        state: c.getResponseHeader("x-state")
                    }, a.onSuccess(b)
                },
                error: a.onError
            }, f.logInfo("Attempting to create the call..."), void C.doOperation("createCall", d)) : (e = {
                Authorization: a.token,
                options: {}
            }, "call" === a.breed ? (e.options["x-calls-action"] = "call-answer", h = {
                callsMediaModifications: {
                    sdp: a.description.sdp
                }
            }) : (e.options["x-conference-action"] = "call-answer", h = {
                conferenceModifications: {
                    sdp: a.description.sdp
                }
            }), c = {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        callId: a.callId,
                        type: a.breed + "s"
                    },
                    headers: e
                },
                data: h,
                success: function(c) {
                    f.logDebug("doOperation(modifyCall): success"), f.logInfo("Success during answering call/conference"), f.logTrace("response", c), b = {
                        state: c.getResponseHeader("x-state")
                    }, a.onSuccess(b)
                },
                error: a.onError
            }, f.logInfo("Attempting to answer the call..."), void C.doOperation("modifyCall", c))
        }

        function n(a) {
            f.logDebug("ATT.private.RTCManager: acceptMediaModifications"), f.logTrace("acceptMediaModOpts", a);
            var b, c, d = "call" === a.breed ? "calls" : "conferences";
            b = {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: d,
                        callId: a.callId
                    },
                    headers: {
                        Authorization: a.token,
                        "x-modId": a.modId
                    }
                },
                data: {
                    callsMediaModifications: {
                        sdp: a.sdp
                    }
                },
                success: function() {
                    f.logDebug("doOperation(acceptMediaModifications): success"), f.logInfo("Successfully accepted media modifications for call")
                },
                error: function(a) {
                    f.logDebug("doOperation(acceptMediaModifications): error"), f.logError("Error during accepting media modifications for call"), f.logTrace(a)
                }
            }, c = {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: d,
                        callId: a.callId
                    },
                    headers: {
                        Authorization: a.token,
                        "x-mod-Id": a.modId
                    }
                },
                data: {
                    conferenceModifications: {
                        sdp: a.sdp
                    }
                },
                success: function() {
                    f.logDebug("doOperation(acceptConferenceModifications): success"), f.logInfo("Successfully accepted media modifications for conference")
                },
                error: function(a) {
                    f.logDebug("doOperation(acceptConferenceModifications): error"), f.logError("Error during accepting media modifications for conference"), f.logTrace(a)
                }
            }, f.logInfo("Attempting to accept media modifications for the " + a.breed), "calls" === d ? C.doOperation("acceptCallModifications", b) : C.doOperation("acceptConferenceModifications", c)
        }

        function o(a) {
            f.logDebug("ATT.private.RTCManager: addParticipant"), f.logTrace("addParticipantOpts", a);
            var b, d;
            if (void 0 === a) throw new Error("No `options` passed");
            if (void 0 === a.sessionInfo) throw new Error("No `sessionInfo` passed");
            if (void 0 === a.confId) throw new Error("No `confId` passed");
            if ("function" != typeof a.onSuccess) throw new Error("No `onSuccess` callback passed");
            b = a.invitee.toString(), b = b.indexOf("@") > -1 ? "sip:" + b : "tel:+" + b, f.logInfo("Attempting to add a participant to the conference"), C.doOperation("addParticipant", {
                params: {
                    url: [a.sessionInfo.sessionId, a.confId, b],
                    headers: {
                        Authorization: a.sessionInfo.token
                    }
                },
                success: function(b) {
                    f.logDebug("doOperation(addParticipant): success"), f.logInfo("Successfully added participant to the conference"), f.logTrace("response", b), "add-pending" === b.getResponseHeader("x-state") && (d = b.getResponseHeader("x-modId"), a.onSuccess(d))
                },
                error: function(b) {
                    f.logDebug("doOperation(addParticipant): error"), f.logError("Error during adding a participant to the conference"), f.logTrace(b), a.onError(c.createAPIErrorCode(b, "ATT.rtc.Phone", "addParticipant", "RTC"))
                }
            })
        }

        function p(a) {
            f.logDebug("ATT.private.RTCManager: removeParticipant"), f.logTrace("removeParticipantOpts", a);
            var b;
            if (void 0 === a) throw new Error("No `options` passed");
            if (void 0 === a.sessionInfo) throw new Error("No `sessionInfo` passed");
            if (void 0 === a.confId) throw new Error("No `confId` passed");
            if ("function" != typeof a.onSuccess) throw new Error("No `onSuccess` callback passed");
            b = a.participant.toString(), b = b.indexOf("@") > -1 ? "sip:" + b : "tel:+" + b, f.logInfo("Attempting to remove a participant from the the conference"), C.doOperation("removeParticipant", {
                params: {
                    url: [a.sessionInfo.sessionId, a.confId, b],
                    headers: {
                        Authorization: a.sessionInfo.token
                    }
                },
                success: function(b) {
                    f.logDebug("doOperation(removeParticipant): success"), f.logInfo("Successfully removed participant from the conference"), f.logTrace("response", b), "remove-pending" === b.getResponseHeader("x-state") && a.onSuccess()
                },
                error: function(b) {
                    f.logDebug("doOperation(removeParticipant): error"), f.logError("Error during removing participant from the conference"), f.logTrace(b), a.onError(b)
                }
            })
        }

        function q(a) {
            if (f.logDebug("ATT.private.RTCManager: disconnectCall"), f.logTrace("disconnectCallOpts", a), void 0 === a) throw new Error("No options provided");
            if (void 0 === a.callId) throw new Error("No CallId provided");
            if (void 0 === a.breed) throw new Error("No call breed provided");
            if (void 0 === a.sessionId) throw new Error("No sessionId provided");
            if (void 0 === a.token) throw new Error("No token provided");
            if (void 0 === a.onSuccess) throw new Error("No success callback provided");
            if (void 0 === a.onError) throw new Error("No error callback provided");
            var b = "call" === a.breed ? "hangup" : "endConference";
            f.logInfo("Attempting to delete the " + a.breed), C.doOperation("deleteCall", {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: a.breed + "s",
                        callId: a.callId
                    },
                    headers: {
                        Authorization: a.token,
                        "x-delete-reason": "terminate"
                    }
                },
                success: function() {
                    f.logDebug("doOperation(deleteCall): success"), f.logInfo("Successfully deleted the " + a.breed)
                },
                error: function(d) {
                    f.logDebug("doOperation(deleteCall): error"), f.logError("Error deleting the " + a.breed), f.logTrace(d), a.onError(c.createAPIErrorCode(d, "ATT.rtc.Phone", b, "RTC"))
                }
            })
        }

        function r(a) {
            if (f.logDebug("ATT.private.RTCManager: cancelCall"), f.logTrace("cancelCallOpts", a), void 0 === a) throw new Error("No options provided");
            if (void 0 === a.callId) throw new Error("No callId provided");
            if (void 0 === a.breed) throw new Error("No call breed provided");
            if (void 0 === a.sessionId) throw new Error("No sessionId provided");
            if (void 0 === a.token) throw new Error("No token provided");
            if (void 0 === a.onSuccess) throw new Error("No success callback provided");
            if (void 0 === a.onError) throw new Error("No error callback provided");
            a.callId.length > 0 && (f.logInfo("Attempting to cancel the " + a.breed), C.doOperation("deleteCall", {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: a.breed + "s",
                        callId: a.callId
                    },
                    headers: {
                        Authorization: a.token,
                        "x-delete-reason": "cancel"
                    }
                },
                success: function() {
                    f.logDebug("doOperation(deleteCall): success"), f.logInfo("Successfully deleted the " + a.breed), a.onSuccess()
                },
                error: function(b) {
                    f.logDebug("doOperation(deleteCall): error"), f.logError("Error canceling the " + a.breed), f.logTrace(b), a.onError(c.createAPIErrorCode(b, "ATT.rtc.Phone", "cancel", "RTC"))
                }
            }))
        }

        function s(a, b) {
            f.logDebug("ATT.private.RTCManager: holdOrMoveCall"), f.logTrace("holdOrMoveCallOpts", a), f.logTrace("action", b);
            var d, e, g;
            if (void 0 !== a && (g = "move" === b ? "move" : "hold"), void 0 === a) throw new Error("No options provided");
            if (void 0 === a.callId) throw new Error("No callId provided");
            if (void 0 === a.sessionId) throw new Error("No sessionId provided");
            if (void 0 === a.token) throw new Error("No token provided");
            if (void 0 === a.description) throw new Error("No sdp provided");
            if (void 0 === a.breed) throw new Error("No breed provided");
            if (void 0 === a.onSuccess) throw new Error("No success callback provided");
            if (void 0 === a.onError) throw new Error("No error callback provided");
            e = {
                Authorization: a.token,
                options: {}
            }, f.logDebug("Modification data:"), "conference" === a.breed ? (d = {
                conferenceModifications: {
                    sdp: a.description.sdp,
                    type: a.description.type
                }
            }, e.options["x-conference-action"] = "initiate-hold", f.logTrace("sdp", d.conferenceModifications.sdp), f.logTrace("type", d.conferenceModifications.type)) : (d = {
                callsMediaModifications: {
                    sdp: a.description.sdp,
                    type: a.description.type
                }
            }, e.options["x-calls-action"] = "initiate-call-" + g, f.logTrace("sdp", d.callsMediaModifications.sdp), f.logTrace("type", d.callsMediaModifications.type)), f.logInfo("Attempting to " + g + " the " + a.breed), C.doOperation("modifyCall", {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: a.breed + "s",
                        callId: a.callId
                    },
                    headers: e
                },
                data: d,
                success: function(b) {
                    f.logDebug("doOperation(modifyCall): success"), f.logInfo("Successfully performed operation " + g + " on the " + a.breed), f.logTrace("response", b), 204 === b.getResponseStatus() ? (f.logInfo("Response Status 204"), a.onSuccess()) : (f.logError("Response Status is not 204"), a.onError())
                },
                error: function(b) {
                    f.logDebug("doOperation(modifyCall): error"), f.logError("Error during performing operation" + g + " on the " + a.breed), f.logTrace(b), a.onError(c.createAPIErrorCode(b, "ATT.rtc.Phone", g, "RTC"))
                }
            })
        }

        function t(a) {
            f.logDebug("ATT.private.RTCManager: holdCall"), f.logTrace("holdCallOpts", a), s(a, "hold")
        }

        function u(a) {
            f.logDebug("ATT.private.RTCManager: moveCall"), f.logTrace("moveCallOpts", a), s(a, "move")
        }

        function v(a) {
            f.logDebug("ATT.private.RTCManager: resumeCall"), f.logTrace("resumeCallOpts", a);
            var b, d;
            if (void 0 === a) throw new Error("No options provided");
            if (void 0 === a.callId) throw new Error("No callId provided");
            if (void 0 === a.sessionId) throw new Error("No sessionId provided");
            if (void 0 === a.token) throw new Error("No token provided");
            if (void 0 === a.description) throw new Error("No sdp provided");
            if (void 0 === a.breed) throw new Error("No breed provided");
            if (void 0 === a.onSuccess) throw new Error("No success callback provided");
            if (void 0 === a.onError) throw new Error("No error callback provided");
            d = {
                Authorization: a.token,
                options: {}
            }, "conference" === a.breed ? (b = {
                conferenceModifications: {
                    sdp: a.description.sdp,
                    type: a.description.type
                }
            }, d.options["x-conference-action"] = "initiate-resume") : (b = {
                callsMediaModifications: {
                    sdp: a.description.sdp,
                    type: a.description.type
                }
            }, d.options["x-calls-action"] = "initiate-call-resume"), f.logInfo("Attempting to resume the " + a.breed), C.doOperation("modifyCall", {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: a.breed + "s",
                        callId: a.callId
                    },
                    headers: d
                },
                data: b,
                success: function(b) {
                    f.logDebug("doOperation(modifyCall): success"), f.logInfo("Successfully resuming the " + a.breed), f.logTrace("response", b), 204 === b.getResponseStatus() ? (f.logTrace("resume request sent..."), a.onSuccess()) : a.onError()
                },
                error: function(b) {
                    f.logDebug("doOperation(modifyCall): error"), f.logError("Error resuming the " + a.breed), f.logTrace(b), a.onError(c.createAPIErrorCode(b, "ATT.rtc.Phone", "resume", "RTC"))
                }
            })
        }

        function w(a) {
            f.logDebug("ATT.private.RTCManager: associateE911Id"), f.logTrace("associateE911IdOpts", a);
            var b;
            if (void 0 === a) throw "Invalid options";
            if (void 0 === a.token || "" === a.token) throw "No token passed";
            if (void 0 === a.e911Id || "" === a.e911Id) throw "No e911Id passed";
            if (void 0 === a.sessionId || "" === a.sessionId) throw "No session Id passed";
            if (void 0 === a.onSuccess || "function" != typeof a.onSuccess) throw "No success callback passed";
            if (void 0 === a.onError || "function" != typeof a.onError) throw "No error callback passed";
            b = {
                data: {
                    e911Association: {
                        e911Id: a.e911Id
                    }
                },
                params: {
                    url: [a.sessionId],
                    headers: {
                        Authorization: a.token
                    }
                },
                success: a.onSuccess,
                error: function(b) {
                    f.logDebug("doOperation(associateE911Id): error"), f.logError("Error associating e911 id with the session"), f.logTrace(b), a.onError(c.createAPIErrorCode(b, "ATT.rtc.Phone", "associateE911Id", "RTC"))
                }
            }, f.logInfo("Attempting to associate the e911Id with session..."), C.doOperation("associateE911Id", b)
        }

        function x(a) {
            if (f.logDebug("ATT.private.RTCManager: associateE911Id"), f.logTrace("associateTokenOpts", a), void 0 === a) throw new Error("No options provided.");
            if (void 0 === a.userId) throw new Error("No userId provided.");
            if (void 0 === a.token) throw new Error("No token provided.");
            f.logInfo("Attempting to associate token with the user id..."), C.doOperation("associateTokenWithUserId", {
                params: {
                    url: {
                        userId: a.userId
                    },
                    headers: {
                        Authorization: a.token
                    }
                },
                success: function() {
                    f.logDebug("doOperation(associateTokenWithUserId): success"), f.logInfo("Successfully associated token with user id"), a.success()
                },
                error: function(b) {
                    f.logDebug("doOperation(associateTokenWithUserId): error"), f.logError("Error associating token with the user id"), f.logTrace(b), a.error(b)
                }
            })
        }

        function y(a) {
            if (f.logDebug("ATT.private.RTCManager: associateE911Id"), f.logTrace("rejectCallOpts", a), void 0 === a) throw new Error("Invalid options");
            if (void 0 === a.callId || "" === a.callId) throw new Error("No callId provided");
            if (void 0 === a.breed || "" === a.breed) throw new Error("No call breed provided");
            if (void 0 === a.sessionId || "" === a.sessionId) throw new Error("No session Id provided");
            if (void 0 === a.token || "" === a.token) throw new Error("No token provided");
            if (void 0 === a.onSuccess || "function" != typeof a.onSuccess) throw new Error("No success callback provided");
            if (void 0 === a.onError || "function" != typeof a.onError) throw new Error("No error callback provided");
            var b = "call" === a.breed ? "reject" : "rejectConference";
            f.logInfo("Attempting to reject the " + a.breed), C.doOperation("deleteCall", {
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: a.breed + "s",
                        callId: a.callId
                    },
                    headers: {
                        Authorization: a.token,
                        "x-delete-reason": "reject"
                    }
                },
                success: function() {
                    f.logDebug("doOperation(deleteCall): success"), f.logInfo("Successfully deleted the " + a.breed)
                },
                error: function(d) {
                    f.logDebug("doOperation(deleteCall): error"), f.logError("Error deleting the " + a.breed), f.logTrace(d), a.onError(c.createAPIErrorCode(d, "ATT.rtc.Phone", b, "RTC"))
                }
            })
        }

        function z(a) {
            if (f.logDebug("ATT.private.RTCManager: transferCall"), f.logTrace("transferCallOpts", a), void 0 === a || 0 === Object.keys(a).length) throw new Error("No options provided");
            if (void 0 === a.callId) throw new Error("No call id provided");
            if (void 0 === a.breed) throw new Error("No call breed provided");
            if (void 0 === a.sessionId) throw new Error("No session id provided");
            if (void 0 === a.token) throw new Error("No token provided");
            if (void 0 === a.targetCallId) throw new Error("No target call id provided");
            if (void 0 === a.transfereeSdp) throw new Error("No sdp provided");
            if (void 0 === a.success) throw new Error("No success callback provided");
            if (void 0 === a.error) throw new Error("No error callback provided");
            f.logInfo("Attempting to transfer the " + a.breed), C.doOperation("transferCall", {
                data: {
                    callsMediaModifications: {
                        sdp: a.transfereeSdp
                    }
                },
                params: {
                    url: {
                        sessionId: a.sessionId,
                        type: a.breed + "s",
                        callId: a.callId
                    },
                    headers: {
                        Authorization: a.token,
                        "x-transferTargetCallId": a.targetCallId
                    }
                },
                success: function() {
                    f.logDebug("doOperation(transferCall): success"), f.logInfo("Successfully transferred the " + a.breed), a.success()
                },
                error: function(b) {
                    f.logDebug("doOperation(transferCall): error"), f.logError("Error transferring the " + a.breed), f.logTrace(b), a.error(b)
                }
            })
        }
        var A, B, C;
        C = a.resourceManager, f.logDebug("ATT.private.RTCManager: Constructor"), f.logTrace("options", a), A = e.getAppConfiguration(), B = b.createEventManager({
            resourceManager: C,
            eventChannelType: A.eventChannelType
        }), this.on = h, this.off = i, this.connectSession = k, this.disconnectSession = l, this.connectCall = m, this.acceptMediaModifications = n, this.addParticipant = o, this.removeParticipant = p, this.disconnectCall = q, this.refreshSession = j, this.cancelCall = r, this.holdCall = t, this.moveCall = u, this.resumeCall = v, this.rejectCall = y, this.transferCall = z, this.associateE911Id = w, this.associateToken = x
    }
    var b = ATT["private"].factories,
        c = ATT["private"].error,
        d = ATT["private"].config.api,
        e = ATT["private"].config.app,
        f = ATT.logManager.createLogger("rtcManager"),
        g = ATT.utils;
    if (void 0 === ATT["private"]) throw new Error("Error exporting `RTCManager`");
    ATT["private"].RTCManager = a, ATT["private"].rtcManager = function() {
        var c, e;
        return {
            getRTCManager: function() {
                return void 0 === c && (e = b.createResourceManager(d), c = new a({
                    resourceManager: e
                })), c
            }
        }
    }()
}();
var RTCPeerConnection = null,
    RTCSessionDescription, RTCIceCandidate = null,
    getUserMedia = null,
    attachMediaStream = null,
    reattachMediaStream = null,
    webrtcDetectedBrowser = null,
    webrtcDetectedVersion = null,
    logger = ATT.logManager.createLogger("adapter"),
    createIceServer;
if (navigator.mozGetUserMedia) logger.logInfo("This appears to be Firefox"), logger.logInfo(navigator.userAgent), webrtcDetectedBrowser = "firefox", webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10), RTCPeerConnection = mozRTCPeerConnection, RTCSessionDescription = mozRTCSessionDescription, RTCIceCandidate = mozRTCIceCandidate, getUserMedia = navigator.mozGetUserMedia.bind(navigator), createIceServer = function(a, b, c) {
    var d, e = null,
        f = a.split(":");
    return 0 === f[0].indexOf("stun") ? e = {
        url: a
    } : 0 === f[0].indexOf("turn") ? webrtcDetectedVersion >= 27 ? e = {
        url: a,
        credential: c,
        username: b
    } : (d = a.split("?"), 0 === d[1].indexOf("transport=udp") ? e = {
        url: d[0],
        credential: c,
        username: b
    } : null) : void 0
}, attachMediaStream = function(a, b) {
    logger.logInfo("Attaching media stream"), a.mozSrcObject = b, a.play()
}, reattachMediaStream = function(a, b) {
    logger.logInfo("Reattaching media stream"), a.mozSrcObject = b.mozSrcObject, a.play()
}, MediaStream.prototype.getVideoTracks || (MediaStream.prototype.getVideoTracks = function() {
    return []
}), MediaStream.prototype.getAudioTracks || (MediaStream.prototype.getAudioTracks = function() {
    return []
});
else if (navigator.webkitGetUserMedia) {
    logger.logInfo("This appears to be Chrome"), logger.logInfo(navigator.userAgent), webrtcDetectedBrowser = "chrome", webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
    var createIceServer = function(a, b, c) {
        var d = null,
            e = a.split(":");
        return 0 === e[0].indexOf("stun") ? d = {
            url: a
        } : 0 === e[0].indexOf("turn") && (d = {
            url: a,
            credential: c,
            username: b
        }), d
    };
    RTCPeerConnection = webkitRTCPeerConnection, getUserMedia = navigator.webkitGetUserMedia.bind(navigator), attachMediaStream = function(a, b) {
        "undefined" !== a.srcObject ? a.srcObject = b : "undefined" !== a.mozSrcObject ? a.mozSrcObject = b : "undefined" !== a.src ? a.src = URL.createObjectURL(b) : logger.logError("Error attaching stream to element.")
    }, reattachMediaStream = function(a, b) {
        a.src = b.src
    }
} else logger.logError("Browser does not appear to be WebRTC-capable");
! function(a) {
    "use strict";
    var b, c = {
            audio: !0,
            video: !0
        },
        d = ATT.logManager.createLogger("userMediaService");
    d.logDebug("Loading att.user-media-service"), b = {
        localMedia: null,
        remoteMedia: null,
        localStream: null,
        remoteStream: null,
        mediaConstraints: null,
        onUserMedia: null,
        onMediaEstablished: null,
        onUserMediaError: null,
        getUserMedia: function(a) {
            d.logDebug("ATT.UserMediaService: getUserMedia"), d.logInfo("Trying to get the user media"), d.logTrace(a);
            var b = this;
            this.localMedia = a.localMedia, this.remoteMedia = a.remoteMedia, this.mediaConstraints = c, this.onUserMedia = a.onUserMedia, this.onMediaEstablished = a.onMediaEstablished, this.onUserMediaError = a.onUserMediaError, void 0 !== a.mediaType && (this.mediaConstraints.video = "audio" !== a.mediaType), this.mediaConstraints.fake = !0 === a.fake, getUserMedia(this.mediaConstraints, b.getUserMediaSuccess.bind(b), function(b) {
                d.logDebug("getUserMedia: error"), d.logError("error getting user media"), d.logTrace("mediaError", b);
                var c = ATT.errorDictionary.getSDKError(14e3);
                a.onUserMediaError(c), d.logError(c)
            })
        },
        getUserMediaSuccess: function(a) {
            d.logDebug("getUserMedia: success"), d.logInfo("Got the user media."), d.logTrace("stream", a), this.showStream({
                localOrRemote: "local",
                stream: a
            });
            var b = {
                mediaConstraints: this.mediaConstraints,
                localStream: a
            };
            this.onUserMedia(b)
        },
        showStream: function(a) {
            d.logDebug("ATT.UserMediaService: showStream"), d.logTrace(a);
            var b;
            try {
                "remote" === a.localOrRemote ? (this.remoteStream = a.stream, b = this.remoteMedia) : (this.localStream = a.stream, b = this.localMedia, b.setAttribute("muted", "")), b && (b.src = window.URL.createObjectURL(a.stream), d.logInfo("About to play " + a.localOrRemote + " stream..."), b.play(), "remote" === a.localOrRemote && this.onMediaEstablished())
            } catch (c) {
                d.logError("Error during showStream"), d.logTrace(c), void 0 !== this.onUserMediaError && "function" == typeof this.onUserMediaError && this.onUserMediaError(c)
            }
        },
        stopUserMedia: function() {
            d.logDebug("ATT.UserMediaService: stopUserMedia");
            try {
                this.localStream && (d.logInfo("Stopping the local stream..."), this.localStream.stop(), this.localStream = null, this.localMedia.src = ""), this.remoteStream && "function" == typeof this.remoteStream.stop && (d.logInfo("Stopping the remote stream..."), this.remoteStream.stop(), this.remoteStream = null, this.remoteMedia.src = "")
            } catch (a) {
                d.logError("Error stopping local and remote streams"), d.logTrace(a), this.onUserMediaError(a)
            }
        }
    }, a.UserMediaService = b
}(ATT),
function() {
    "use strict";

    function a(a) {
        function c(a, c) {
            b.logDebug("ATT.private.peer-connection: processDescription"), b.logTrace("description", a), b.logInfo("Trying to set the local description..."), g.setLocalDescription(a, function() {
                b.logDebug("processDescription:setLocalDescription: success"), b.logInfo("Successfully set the local description during processDescription"), void 0 !== c && "function" == typeof c && c(a)
            }, function(a) {
                b.logDebug("processDescription:setLocalDescription: error"), b.logError("Error during processDescription:setLocalDescription"), b.logTrace(a), j(a)
            })
        }

        function d(a) {
            var b, c;
            if (k.OfferToReceiveVideo) {
                if (b = a.split("m=audio")[1].split("m=video")[0], c = a.split("m=video")[1], c.match(/1 udp/i) && b.match(/1 udp/i)) return !0
            } else if (b = a.split("m=audio")[1], b.match(/1 udp/i)) return !0;
            return !1
        }

        function e() {
            b.logDebug("ATT.private.peer-connection: createSdpOffer"), b.logInfo("Trying to create an SDP offer..."), g.createOffer(function(a) {
                b.logDebug("createOffer: success"), b.logInfo("Successfully created the sdp offer"), b.logTrace("local description", a), b.logInfo("Trying to set the local description..."), g.setLocalDescription(a, function() {
                    b.logDebug("createOffer:setLocalDescription: success"), b.logInfo("Successfully set the local description during createSdpOffer")
                }, function(a) {
                    b.logDebug("createSdpOffer:setLocalDescription: error"), b.logError("Error during createSdpOffer:setLocalDescription"), b.logTrace(a), j(a)
                })
            }, function(a) {
                b.logError("Error during createSdpOffer"), b.logTrace(a), j(a)
            }, {
                mandatory: k
            })
        }

        function f(a) {
            b.logDebug("ATT.private.peer-connection: acceptSdpOffer"), b.logTrace("acceptSdpOffer.options", a);
            try {
                b.logInfo("Trying to set the remote description..."), g.setRemoteDescription(new RTCSessionDescription({
                    sdp: a.remoteSdp,
                    type: "offer"
                }), function() {
                    b.logDebug("acceptSdpOffer:setRemoteDescription: success"), b.logInfo("Trying to set the create the SDP answer...");
                    try {
                        g.createAnswer(function(d) {
                            b.logDebug("createAnswer: success"), b.logInfo("Successfully created the SDP answer"), b.logTrace("description.type", d.type), b.logTrace("description.sdp", d.sdp), c(d, a.onSuccess)
                        }, function(a) {
                            b.logDebug("createAnswer: error"), b.logInfo("Error creating the SDP answer"), b.logTrace(a), j(a)
                        }, {
                            mandatory: k
                        })
                    } catch (d) {
                        throw b.logError("Error during acceptSdpOffer:createAnswer"), b.logTrace(d), d
                    }
                }, function(a) {
                    b.logDebug("acceptSdpOffer:setRemoteDescription: error"), b.logInfo("Error during acceptSdpOffer:setRemoteDescription"), b.logTrace(a), j(a)
                })
            } catch (d) {
                throw b.logError("Error during acceptSdpOffer"), b.logTrace(d), d
            }
        }
        b.logDebug("ATT.private.factories: createPeerConnection"), b.logTrace("createPeerConnection.options", a);
        var g, h, i, j, k, l, m, n = !1;
        if (void 0 === a || 0 === Object.keys(a).length) throw b.logError("No options passed."), new Error("No options passed.");
        if (void 0 === a.stream) throw b.logError("No `stream` passed."), new Error("No `stream` passed.");
        if (void 0 === a.mediaType) throw b.logError("No `mediaType` passed."), new Error("No `mediaType` passed.");
        if ("function" != typeof a.onSuccess) throw b.logError("No `onSuccess` callback passed."), new Error("No `onSuccess` callback passed.");
        if (h = a.onSuccess, "function" != typeof a.onRemoteStream) throw b.logError("No `onRemoteStream` callback passed."), new Error("No `onRemoteStream` callback passed.");
        if (i = a.onRemoteStream, "function" != typeof a.onError) throw b.logError("No `onError` callback passed."), new Error("No `onError` callback passed.");
        if ("object" != typeof a.pcConfiguration) throw b.logError("No `pcConfiguration` parameter passed."), new Error("No `pcConfiguration` parameter passed.");
        j = a.onError, k = {
            OfferToReceiveAudio: !0,
            OfferToReceiveVideo: "video" === a.mediaType
        };
        try {
            b.logInfo("Creating the peer connection"), l = {
                iceServers: a.pcConfiguration.iceServers,
                iceTransports: a.pcConfiguration.iceTransports
            }, m = {
                optional: [{
                    googIPv6: a.pcConfiguration.ipv6
                }]
            }, g = new RTCPeerConnection(l, m)
        } catch (o) {
            throw b.logError("Failed to create PeerConnection."), b.logTrace(o), new Error("Failed to create PeerConnection.")
        }
        return g.addStream(a.stream), g.onaddstream = function(a) {
            i(a.stream)
        }, void 0 === a.remoteSdp && (a.remoteSdp = null), g.onicecandidate = function(a) {
            b.logDebug("createPeerConnection: onIceCandidate"), n || d(g.localDescription.sdp) && (h(g.localDescription), n = !0), b.logInfo(a.candidate ? "Candidate: " + a.candidate : "End of candidates")
        }, null === a.remoteSdp ? e() : f({
            remoteSdp: a.remoteSdp
        }), b.logInfo("Peer connection created"), b.logTrace("Peer connection", g), {
            getLocalDescription: function() {
                return g.localDescription
            },
            setRemoteDescription: function(a) {
                g.setRemoteDescription(new RTCSessionDescription(a), function() {
                    b.logInfo("setRemoteDescription: success")
                }, function(a) {
                    b.logInfo("error while setting remote description"), b.logError(a), b.logError("setRemoteDescription: error"), b.logTrace("setRemoteDescription: error", a), j(a)
                })
            },
            setLocalDescription: function(a) {
                g.setLocalDescription(a, function() {
                    b.logDebug("processDescription:setLocalDescription: success"), b.logInfo("Successfully set the local description during processDescription")
                }, function(a) {
                    b.logDebug("processDescription:setLocalDescription: error"), b.logError("Error during processDescription:setLocalDescription"), b.logTrace(a), j(a)
                })
            },
            acceptSdpOffer: f,
            getRemoteDescription: function() {
                return g.remoteDescription
            },
            close: function() {
                g.close(), g = null
            }
        }
    }
    var b = ATT.logManager.createLogger("peerConnection");
    if (b.logDebug("Loading att.peer-connection"), void 0 === ATT["private"].factories) throw new Error("Error exporting `ATT.private.factories.createPeerConnection`");
    ATT["private"].factories.createPeerConnection = a
}(),
function() {
    "use strict";

    function a(a) {
        function g() {
            var a = {
                index: T,
                timestamp: new Date,
                mediaType: V
            };
            return void 0 !== ga && (a.codec = ga), void 0 !== Z && (a.downgrade = Z), W === c.CALL_TYPE.OUTGOING ? a.to = S : W === c.CALL_TYPE.INCOMING && (a.from = S), Object.keys(_).length > 0 && (a.invitations = _), Object.keys(aa).length > 0 && (a.participants = aa), a
        }

        function h() {
            return fa
        }

        function i(a) {
            fa = a, ja.publish(fa, g.call(this))
        }

        function j(a, b) {
            var c, d, e, f = $.invitations();
            for (c in f) f.hasOwnProperty(c) && (d = f[c], a === d.id && (e = d.invitee, aa[e] = {
                participant: e,
                status: b
            }, ja.publish("invite-accepted", g())))
        }

        function k(a, b, c) {
            _[a] = {
                invitee: a,
                id: b,
                status: c
            }
        }

        function l(a, b) {
            var c, d, e, f = $.invitations();
            for (c in f) f.hasOwnProperty(c) && (d = f[c], a === d.id && (e = d.invitee, _[e].status = b))
        }

        function m(a) {
            return a.toString(), a.indexOf("tel") > -1 ? a.split("+")[1] : a.indexOf("sip") > -1 ? a.split(":")[1].split("@")[0] : a
        }

        function n(a) {
            e.logDebug("ATT.rtc.Call: toggleLocalAudio");
            var b, c, d = $.localStream();
            if (null !== d)
                for (b = d.getAudioTracks(), c = 0; c < b.length; c += 1) b[c].enabled = a
        }

        function o(a) {
            e.logDebug("ATT.rtc.Call: toggleLocalVideo");
            var b, c, d = $.localStream();
            if (null !== d)
                for (b = d.getVideoTracks(), c = 0; c < b.length; c += 1) b[c].enabled = a
        }

        function p() {
            e.logDebug("ATT.rtc.Call: disableLocalMedia"), n(!1), o(!1)
        }

        function q() {
            e.logDebug("ATT.rtc.Call: enableLocalMedia"), n(!0), o(!0)
        }

        function r(a) {
            if (e.logDebug("Event: onModReceived"), e.logTrace("modificationId", a.modificationId), e.logTrace("remoteSdp", a.remoteSdp), la = a.modificationId, void 0 === a.remoteSdp) return e.logInfo("No remote sdp, accepting media modifications"), ka.acceptMediaModifications({
                sessionId: Y.sessionId,
                token: Y.token,
                callId: R,
                breed: X,
                sdp: $.localSdp().sdp,
                modId: la
            }), void(la = "");
            if (e.logInfo("Remote sdp exists, accepting sdp offer"), void 0 !== a.remoteSdp) {
                var b;
                b = f.removeSDPAttribute("rtcp-fb:100 nack", a.remoteSdp), b = f.setupActivePassive(b), U.acceptSdpOffer({
                    remoteSdp: b,
                    onSuccess: function(a) {
                        e.logDebug("acceptSdpOffer: onSuccess"), e.logInfo("Successfully accepted SDP offer"), e.logTrace("local description", a), ka.acceptMediaModifications({
                            sessionId: Y.sessionId,
                            token: Y.token,
                            callId: R,
                            breed: X,
                            sdp: a.sdp,
                            modId: la
                        }), la = ""
                    }
                })
            }
        }

        function s(a) {
            e.logDebug("Event: onModTerminated"), e.logTrace("type", a.type), e.logTrace("reason", a.reason), "success" === a.reason && "holding" === fa && (e.logInfo("Call is on hold."), $.setState("held"), U.setRemoteDescription({
                sdp: a.remoteSdp,
                type: "offer"
            })), "resuming" === fa && "success" === a.reason && (e.logInfo("Call is resumed."), $.setState("resumed"), U.setRemoteDescription({
                sdp: a.remoteSdp,
                type: "offer"
            })), void 0 !== a.remoteSdp && (e.logTrace("Remote SDP", a.remoteSdp), "connecting" === fa && U.setRemoteDescription({
                sdp: a.remoteSdp,
                type: "answer"
            })), "conference" === a.type && void 0 !== a.modificationId && (e.logDebug("onModTerminated:conference"), "success" === a.reason && j(a.modificationId, "active"), "Call rejected" === a.reason && (l(a.modificationId, "rejected"), ja.publish("rejected", g()))), "success" !== a.reason && "Call rejected" !== a.reason && ja.publish("notification", ATT.utils.extend(g(), {
                message: a.reason
            }))
        }

        function t(a) {
            e.logDebug("onSessionOpen"), e.logTrace("data", a), a.mediaType && ("audio" === a.mediaType && "video" === V && (Z = !0, o(!1)), V = a.mediaType), a.provisionalSdp || $.setState("connected"), void 0 !== a.remoteSdp && (e.logTrace("Remote SDP", a.remoteSdp), $.setRemoteSdp(a.remoteSdp), U.setRemoteDescription({
                sdp: a.remoteSdp,
                type: "answer"
            }))
        }

        function u(a) {
            e.logDebug("onSessionModified"), $.setState("connecting" === $.getState() ? "connected" : "moved"), ja.publish("stream-added", {
                stream: ea
            }), void 0 !== a.remoteSdp && (e.logTrace("Remote SDP", a.remoteSdp), $.setRemoteSdp(a.remoteSdp), U.setRemoteDescription({
                sdp: a.remoteSdp,
                type: "offer"
            }))
        }

        function v() {
            e.logDebug("att.call.js: onTransferInitiated"), e.logInfo("Transfer initiated successfully"), i("transferring")
        }

        function w(a) {
            return e.logDebug("att.call.js: onTransferTerminated"), e.logInfo("Transfer terminated"), e.logTrace("data", a), "success" !== a.reason ? void ja.publish("error", {
                error: "There was an error transferring the call. " + a.reason
            }) : void i("transferred")
        }

        function x(a) {
            e.logDebug("onSessionTerminated"), e.logTrace(a);
            var b;
            void 0 !== a ? "Call rejected" === a.reason || ia ? i("rejected") : "Call canceled" === a.reason || ha ? i("canceled") : void 0 !== a.reason ? (fa = "disconnected", b = g(), b.message = a.reason, ja.publish("disconnected", b)) : i("created" === fa ? "canceled" : "disconnected") : i("disconnected"), ka.off(c.API_EVENT.SESSION_OPEN + ":" + R, t), ka.off(c.API_EVENT.SESSION_MODIFIED + ":" + R, u), ka.off(c.API_EVENT.SESSION_TERMINATED + ":" + R, x), ka.off(c.API_EVENT.MODIFICATION_RECEIVED + ":" + R, r), ka.off(c.API_EVENT.MODIFICATION_TERMINATED + ":" + R, s), ka.off(c.API_EVENT.TRANSFER_INITIATED + ":" + R, v), ka.off(c.API_EVENT.TRANSFER_TERMINATED + ":" + R, w), void 0 !== U && (U.close(), U = void 0)
        }

        function y(a) {
            var b;
            return ba = $.localSdp(), e.logInfo("Modifying SDP for " + a), ba = f.modifyForHoldCall(ba), b = {
                description: ba,
                sessionId: Y.sessionId,
                token: Y.token,
                breed: X,
                callId: R,
                onSuccess: function() {
                    e.logDebug(a + "Call: onSuccess"), e.logInfo("Operation " + a + " on the call was successful")
                },
                onError: function(b) {
                    e.logDebug(a + "Call: onError"), e.logInfo("Error during " + a + " on the call"), e.logTrace(b), ja.publish("error", {
                        error: b
                    })
                }
            }, "move" === a ? void ka.moveCall(b) : (void 0 !== ba.sdp && e.logTrace("Local SDP", ba.sdp), void ka.holdCall(b))
        }

        function z() {
            e.logDebug("ATT.rtc.Call: registerForRTCEvents"), ka.on(c.API_EVENT.SESSION_OPEN + ":" + R, t), ka.on(c.API_EVENT.SESSION_MODIFIED + ":" + R, u), ka.on(c.API_EVENT.SESSION_TERMINATED + ":" + R, x), ka.on(c.API_EVENT.MODIFICATION_RECEIVED + ":" + R, r), ka.on(c.API_EVENT.MODIFICATION_TERMINATED + ":" + R, s), ka.on(c.API_EVENT.TRANSFER_INITIATED + ":" + R, v), ka.on(c.API_EVENT.TRANSFER_TERMINATED + ":" + R, w)
        }

        function A(a) {
            e.logDebug("ATT.rtc.Call: setId"), e.logTrace(a), R = a, null === R ? (e.logInfo("disconnecting..."), i("disconnected")) : (e.logInfo("connecting..."), i("connecting"))
        }

        function B(a) {
            e.logDebug("ATT.rtc.Call: setRemoteSdp"), ca = a, null !== a && (ga = f.getCodecfromSDP(a), e.logTrace("codec", ga))
        }

        function C(a, b) {
            if (e.logDebug("ATT.rtc.Call: on"), e.logInfo("Subscribing to call event: " + a), "connecting" !== a && "response-pending" !== a && "invite-accepted" !== a && "participant-removed" !== a && "canceled" !== a && "rejected" !== a && "connected" !== a && "muted" !== a && "muted" !== a && "unmuted" !== a && "stream-added" !== a && "error" !== a && "held" !== a && "resumed" !== a && "disconnecting" !== a && "disconnected" !== a && "notification" !== a && "moved" !== a && "transferring" !== a && "transferred" !== a) throw new Error("Event " + a + " not defined");
            ja.unsubscribe(a, b), ja.subscribe(a, b, this)
        }

        function D(a, b) {
            e.logDebug("ATT.rtc.Call: off"), e.logInfo("Unsubscribing from call event: " + a), ja.unsubscribe(a, b)
        }

        function E(a) {
            e.logDebug("ATT.rtc.Call: addStream"), e.logTrace(a), da = a
        }

        function F() {
            function a(a) {
                e.logDebug("createPeerConnection: onSuccess"), e.logTrace(a);
                var b = {
                    sessionId: Y.sessionId,
                    token: Y.token,
                    description: a,
                    breed: X,
                    onSuccess: function(a) {
                        e.logDebug("connectCall: onSuccess"), e.logInfo("Success during connectCall"), e.logTrace(a), c.CALL_TYPE.INCOMING === W ? i("connecting") : (A(a.id), z())
                    },
                    onError: function(a) {
                        e.logDebug("connectCall: onError"), e.logError("Error during connectCall"), e.logTrace(a), ja.publish("error", {
                            error: a
                        })
                    }
                };
                return void 0 !== R && null !== R && (b.callId = R), "call" === X && (b.peer = S), ha ? (e.logInfo("Call is being canceled..."), ha = !1, void x({
                    reason: "Call canceled"
                })) : (e.logInfo("Peer Connection created. Connecting now.."), b.description.sdp = f.fixIcePorts(b.description.sdp), void 0 !== b.description && e.logTrace("Call.connect SDP", b.description.sdp), void ka.connectCall(b))
            }
            e.logDebug("ATT.rtc.Call: connect");
            var d;
            try {
                d = {
                    mediaType: V,
                    stream: da,
                    onSuccess: a,
                    onError: function(a) {
                        e.logDebug("createPeerConnection: onError"), e.logError("Error creating peer connection"), e.logTrace(a), ja.publish("error", {
                            error: a
                        })
                    },
                    onRemoteStream: function(a) {
                        e.logDebug("createPeerConnection: onRemoteStream"), e.logTrace(a), ea = a, ja.publish("stream-added", {
                            stream: a
                        })
                    }
                }, d.pcConfiguration = this.pcConfiguration, d.remoteSdp = ca, d.sdpFilter = f, e.logInfo("Trying to create a peer connection..."), U = b.createPeerConnection(d)
            } catch (g) {
                e.logError("Error during connectCall"), e.logTrace(g), ja.publish("error", {
                    error: g
                })
            }
        }

        function G(a) {
            e.logDebug("ATT.rtc.Call: addParticipant"), e.logInfo("adding participant..."), e.logTrace(a);
            try {
                ka.addParticipant({
                    sessionInfo: Y,
                    invitee: a,
                    confId: R,
                    onSuccess: function(b) {
                        e.logDebug("rtcManager.addParticipant: onSuccess"), e.logInfo("Successfully added participant"), e.logTrace(b), k(m(a), b, "invited"), ja.publish("response-pending", g())
                    },
                    onError: function(a) {
                        e.logDebug("rtcManager.addParticipant: onError"), e.logError("Error adding participant"), e.logTrace(a), ja.publish("error", a)
                    }
                })
            } catch (b) {
                e.logError("Error adding participant"), e.logTrace(b), ja.publish("error", b)
            }
        }

        function H(a) {
            e.logDebug("ATT.rtc.Call: removeParticipant"), e.logTrace(a);
            try {
                ka.removeParticipant({
                    sessionInfo: Y,
                    participant: a,
                    confId: R,
                    onSuccess: function() {
                        e.logDebug("rtcManager.removeParticipant: onSuccess"), e.logInfo("Successfully removed participant"), delete $.participants()[a], ja.publish("participant-removed", g())
                    },
                    onError: function(a) {
                        e.logDebug("rtcManager.removeParticipant: onError"), e.logError("Error removing participant"), e.logTrace(a), ja.publish("error", a)
                    }
                })
            } catch (b) {
                e.logError("Error removing participant"), e.logTrace(b), ja.publish("error", b)
            }
        }

        function I() {
            if (e.logDebug("ATT.rtc.Call: disconnect"), this.on("error", x), "created" === fa || "connecting" === fa) {
                if (e.logInfo("Canceling.."), i("disconnecting"), ha = !0, null === R) return void e.logInfo("Call connecting not completed yet");
                e.logInfo("Call connecting completed. Sending cancel request"), ka.cancelCall({
                    callId: R,
                    breed: X,
                    sessionId: Y.sessionId,
                    token: Y.token,
                    onSuccess: function() {
                        e.logDebug("cancelCall: success"), e.logInfo("Successfully canceled call")
                    },
                    onError: function(a) {
                        e.logDebug("cancelCall: onError"), e.logError("Error canceling call"), e.logTrace(a), ja.publish("error", {
                            error: a
                        })
                    }
                })
            } else null !== R && (e.logInfo("Disconnecting..."), i("disconnecting"), ka.disconnectCall({
                sessionId: Y.sessionId,
                breed: X,
                token: Y.token,
                callId: R,
                onSuccess: function() {
                    e.logDebug("disconnectCall: onSuccess"), e.logInfo("Successfully disconnected call")
                },
                onError: function(a) {
                    e.logDebug("disconnectCall: onError"), e.logError("Error disconnecting call"), e.logTrace(a), ja.publish("error", {
                        error: a
                    })
                }
            }))
        }

        function J() {
            e.logDebug("ATT.rtc.Call: disconnectConference"), e.logInfo("Disconnecting Conference..."), i("disconnecting"), ka.disconnectCall({
                sessionId: Y.sessionId,
                token: Y.token,
                breed: "conference",
                callId: R,
                onSuccess: function() {
                    e.logDebug("disconnectCall: onSuccess"), e.logInfo("Successfully disconnected conference")
                },
                onError: function(a) {
                    e.logDebug("disconnectCall: onError"), e.logError("Error disconnecting conference"), e.logTrace(a), ja.publish("error", {
                        error: a
                    })
                }
            })
        }

        function K() {
            e.logDebug("ATT.rtc.Call: mute"), e.logInfo("Muting call...");
            try {
                n(!1), i("muted")
            } catch (a) {
                e.logError("Error muting call"), e.logTrace(a), ja.publish("error", {
                    error: a
                })
            }
        }

        function L() {
            e.logDebug("ATT.rtc.Call: unmute"), e.logInfo("Unmuting call...");
            try {
                n(!0), i("unmuted")
            } catch (a) {
                e.logError("Error unmuting call"), e.logTrace(a), ja.publish("error", {
                    error: a
                })
            }
        }

        function M() {
            e.logDebug("ATT.rtc.Call: hold"), e.logInfo("Holding call..."), fa = "holding", y("hold")
        }

        function N() {
            e.logDebug("ATT.rtc.Call: move"), e.logInfo("Moving call..."), y("move")
        }

        function O() {
            e.logDebug("ATT.rtc.Call: resume"), e.logInfo("Resuming call..."), ba = $.localSdp(), ba = f.modifyForResumeCall(ba), fa = "resuming", void 0 !== ba.sdp && e.logTrace("Local SDP", ba.sdp), ka.resumeCall({
                description: ba,
                sessionId: Y.sessionId,
                token: Y.token,
                callId: R,
                breed: X,
                onSuccess: function() {
                    e.logDebug("resumeCall: onSuccess"), e.logInfo("Successfully resumed the call")
                },
                onError: function(a) {
                    e.logDebug("resumeCall: onError"), e.logError("Error resuming the call"), e.logTrace(a), ja.publish("error", {
                        error: a
                    })
                }
            })
        }

        function P() {
            e.logDebug("ATT.rtc.Call: reject"), e.logInfo("Rejecting call..."), ia = !0, ka.rejectCall({
                callId: R,
                sessionId: Y.sessionId,
                token: Y.token,
                breed: X,
                onSuccess: function() {
                    e.logDebug("rejectCall: onSuccess"), e.logInfo("Successfully rejected the call")
                },
                onError: function(a) {
                    e.logDebug("rejectCall: onError"), e.logError("Error rejecting the call"), e.logTrace(a), ja.publish("error", a)
                }
            })
        }

        function Q(a) {
            if (e.logDebug("ATT.rtc.Call: transfer"), e.logInfo("Transferring call..."), e.logTrace(a), void 0 === a || 0 === Object.keys(a).length || void 0 === a.targetCallId) throw new Error("No targetCallId provided");
            ka.transferCall({
                callId: R,
                breed: X,
                sessionId: Y.sessionId,
                token: Y.token,
                targetCallId: a.targetCallId,
                transfereeSdp: U.getRemoteDescription().sdp,
                success: function() {
                    e.logDebug("transferCall: success"), e.logInfo("Successfully transferred the call"), "function" == typeof a.success && a.success()
                },
                error: function(b) {
                    e.logDebug("transferCall: error"), e.logError("Error transferring the call"), e.logTrace(b), "function" == typeof a.error && a.error(b)
                }
            })
        }
        e.logDebug("ATT.rtc.Call: Constructor");
        var R, S, T, U, V, W, X, Y, Z, $ = this,
            _ = {},
            aa = {},
            ba = null,
            ca = null,
            da = null,
            ea = null,
            fa = null,
            ga = [],
            ha = !1,
            ia = !1,
            ja = b.createEventEmitter(),
            ka = d.getRTCManager(),
            la = "";
        if (void 0 === a || 0 === Object.keys(a).length) throw new Error("No input provided");
        if (void 0 === a.breed) throw new Error("No breed provided");
        if ("call" === a.breed && void 0 === a.peer) throw new Error("No peer provided");
        if (void 0 === a.type) throw new Error("No type provided");
        if (void 0 === a.mediaType) throw new Error("No mediaType provided");
        if (void 0 === a.pcConfiguration) throw new Error("No peer connection configuration provided");
        X = a.breed, void 0 === a.id ? R = null : (R = a.id, z()), fa = "created", S = a.peer, T = a.index, V = a.mediaType, W = a.type, Y = a.sessionInfo, this.pcConfiguration = a.pcConfiguration, this.index = function() {
            return T
        }, this.peer = function() {
            return S
        }, this.codec = function() {
            return ga
        }, this.mediaType = function() {
            return V
        }, this.type = function() {
            return W
        }, this.breed = function() {
            return X
        }, this.participants = function() {
            return aa
        }, this.invitations = function() {
            return _
        }, this.sessionInfo = function() {
            return Y
        }, this.id = function() {
            return R
        }, this.localSdp = function() {
            return void 0 !== U ? null !== ba ? ba : U.getLocalDescription() : void 0
        }, this.remoteSdp = function() {
            var a;
            return void 0 === U ? ca : (a = U.getRemoteDescription(), a ? a.sdp : null)
        }, this.localStream = function() {
            return da
        }, this.remoteStream = function() {
            return ea
        }, this.canceled = function() {
            return ha
        }, this.rejected = function() {
            return ia
        }, this.setRemoteSdp = B, this.getState = h, this.setState = i, this.setId = A, this.on = C, this.off = D, this.addStream = E, this.connect = F, this.disconnect = I, this.disconnectConference = J, this.addParticipant = G, this.removeParticipant = H, this.mute = K, this.unmute = L, this.hold = M, this.resume = O, this.move = N, this.reject = P, this.transfer = Q, this.disableLocalMedia = p, this.enableLocalMedia = q
    }
    var b = ATT["private"].factories,
        c = ATT["private"]["enum"],
        d = ATT["private"].rtcManager,
        e = ATT.logManager.createLogger("call"),
        f = ATT.sdpFilter.getInstance();
    if (e.logDebug("Loading att.rtc.call..."), void 0 === ATT.rtc) throw new Error("Cannot export Call. ATT.rtc is undefined");
    ATT.rtc.Call = a
}(),
function() {
    "use strict";

    function a() {
        function a(a) {
            d.logDebug("ATT.rtc.Session: onInvitationReceived"), d.logInfo("On getting invitation"), d.logTrace("Call information", a);
            var b, e, f;
            return null !== j.pendingCall ? void h.publish("notification", {
                from: a.from,
                mediaType: a.mediaType,
                type: a.type,
                timestamp: new Date,
                message: "Can only handle one incoming call at a time; ignoring the second incoming call."
            }) : Object.keys(m).length >= 2 ? void h.publish("notification", {
                from: a.from,
                mediaType: a.mediaType,
                type: a.type,
                timestamp: new Date,
                message: "Two calls already in progress, unable to handle a third incoming call."
            }) : (e = j.createCall({
                breed: a.type,
                id: a.id,
                peer: a.from,
                type: c.CALL_TYPE.INCOMING,
                mediaType: a.mediaType
            }), void(void 0 !== e && (a.sdp && (f = a.sdp, a.sdp.indexOf("a=sendonly") >= 0 && (f = f.replace(/a=sendonly/g, "a=inactive")), e.setRemoteSdp(f)), b = "call" === e.breed() ? "call:incoming" : "conference-invite", h.publish(b, {
                from: e.peer(),
                mediaType: e.mediaType(),
                codec: e.codec(),
                timestamp: new Date
            }))))
        }

        function f(a, b) {
            d.logDebug("ATT.rtc.Session: off"), d.logTrace("Un-subscribing from event:", a), h.unsubscribe(a, b)
        }

        function g(a, b) {
            if (d.logDebug("ATT.rtc.Session: on"), d.logTrace("Subscribing to session event: ", a), "ready" !== a && "connecting" !== a && "connected" !== a && "updating" !== a && "needs-refresh" !== a && "notification" !== a && "call:incoming" !== a && "conference-invite" !== a && "call:switched" !== a && "disconnecting" !== a && "disconnected" !== a && "address-updated" !== a && "all-calls-terminated" !== a && "error" !== a) throw d.logError("Event " + a + " not defined"), new Error("Event " + a + " not defined");
            h.unsubscribe(a, b), h.subscribe(a, b, this)
        }
        d.logDebug("ATT.rtc.Session: Constructor");
        var h, i, j = this,
            k = null,
            l = null,
            m = {};
        h = b.createEventEmitter(), i = ATT["private"].rtcManager.getRTCManager(), this.currentPcConfiguration = e.getCurrentPcConfig(), this.defaultPcConfiguration = e.getDefaultPcConfig(), this.timeout = null, this.e911Id = null, this.pendingCall = null, this.currentCall = null, this.timer = null, this.on = g.bind(this), this.off = f.bind(this), this.getToken = function() {
            return d.logDebug("ATT.rtc.Session: getToken"), d.logInfo("Getting the token"), d.logTrace("Token", l), l
        }, this.getId = function() {
            return d.logDebug("ATT.rtc.Session: getId"), d.logInfo("Getting the session Id"), d.logTrace("getId-Session Id", k), k
        }, this.setId = function(a) {
            return d.logDebug("ATT.rtc.Session: setId"), d.logInfo("set the session Id"), d.logTrace("setId-Session Id", a), k = a, null === a ? (d.logDebug("No session Id"), void h.publish("disconnected")) : void h.publish("connected")
        }, this.update = function(a) {
            if (d.logDebug("ATT.rtc.Session: update"), d.logInfo("Updating the session object"), d.logTrace("update-options", a), void 0 === a) throw d.logError("No options provided"), new Error("No options provided");
            if (void 0 !== a.timeout && "number" != typeof a.timeout) throw d.logError("Error invalid Timeout"), new Error("Timeout is not a number.");
            h.publish("updating", a), l = a.token || l, this.e911Id = a.e911Id || this.e911Id, d.logDebug("Updating the session object successfully"), void 0 !== a.timeout && (a.timeout < 6e4 ? this.timeout = a.timeout : this.timeout = a.timeout - 6e4, null !== this.timer && clearInterval(this.timer), this.timer = setInterval(function() {
                h.publish("needs-refresh"), i.refreshSession({
                    sessionId: k,
                    token: l,
                    success: function() {
                        d.logDebug("refreshSession: success"), d.logInfo("Successfully refreshed the session")
                    },
                    error: function(a) {
                        d.logDebug("refreshSession: error"), d.logInfo("Error refreshing the session"), d.logTrace(a), h.publish("error", {
                            error: a
                        })
                    }
                })
            }, this.timeout))
        }, this.connect = function(b) {
            d.logDebug("ATT.rtc.Session: connect"), d.logTrace("connect-options", b);
            try {
                if (void 0 === b) throw d.logError("No options passed"), ATT.errorDictionary.getSDKError("2002");
                if (void 0 === b.token) throw d.logError("No token passed"), ATT.errorDictionary.getSDKError("2001");
                try {
                    l = b.token, this.e911Id = b.e911Id, h.publish("connecting"), j = this, d.logInfo("Connect the session"), i.connectSession({
                        token: b.token,
                        e911Id: b.e911Id,
                        onSessionConnected: function(a) {
                            d.logDebug("connectSession: onSessionConnected"), d.logTrace("Session Information", a);
                            try {
                                j.setId(a.sessionId), j.update({
                                    timeout: a.timeout
                                })
                            } catch (b) {
                                d.logDebug("Error due to rtcManager.connectSession"), d.logError(b), h.publish("error", {
                                    error: ATT.errorDictionary.getSDKError("2004")
                                })
                            }
                        },
                        onSessionReady: function(b) {
                            d.logDebug("connectSession: onSessionReady"), d.logTrace("onSessionReady-data", b), h.publish("ready", b), i.on("invitation-received:" + k, a)
                        },
                        onError: function(a) {
                            d.logDebug("connectSession: onError"), d.logError("Error during connectSession"), d.logTrace("connectSession: error", a), h.publish("error", {
                                error: a
                            })
                        }
                    })
                } catch (c) {
                    throw d.logError("Error during connect"), d.logTrace("connect: error", c), ATT.errorDictionary.getSDKError("2004")
                }
            } catch (c) {
                d.logError("Error during connect"), d.logTrace(c), h.publish("error", {
                    error: c
                })
            }
        }, this.disconnect = function() {
            d.logDebug("ATT.rtc.Session: disconnect");
            try {
                h.publish("disconnecting"), clearInterval(this.timer), d.logInfo("Disconnect the session"), i.disconnectSession({
                    sessionId: j.getId(),
                    token: j.getToken(),
                    e911Id: j.e911Id,
                    onSessionDisconnected: function() {
                        d.logDebug("disconnectSession: onSessionDisconnected");
                        try {
                            j.setId(null)
                        } catch (a) {
                            h.publish("error", {
                                error: a
                            })
                        }
                    },
                    onError: function(a) {
                        d.logDebug("disconnectSession: onError"), d.logError("Error during disconnectSession"), d.logTrace("disconnectSession: error", a);
                        try {
                            j.setId(null)
                        } catch (b) {
                            d.logError("Error setting session id to null"), d.logTrace("setId: error", b)
                        }
                        h.publish("error", {
                            error: a
                        })
                    }
                })
            } catch (a) {
                d.logError("Error during disconnectSession"), d.logTrace(a), h.publish("error", {
                    error: a
                })
            }
        }, this.addCall = function(a) {
            d.logDebug("ATT.rtc.Session: addCall"), d.logInfo("Adding a call in the calls array"), d.logTrace("callId", a.id()), d.logTrace("Before", m), m[a.id()] = a, d.logTrace("After", m)
        }, this.createCall = function(a) {
            function b() {
                var a, b = 0;
                for (a in m) m.hasOwnProperty(a) && b < m[a].index() && (b = m[a].index());
                return b
            }
            d.logDebug("ATT.rtc.Session: createCall"), d.logInfo("Creating a new call"), d.logTrace("CreateCall-options", a);
            var c = new ATT.rtc.Call(ATT.utils.extend(a, {
                pcConfiguration: this.currentPcConfiguration,
                index: b() + 1,
                sessionInfo: {
                    sessionId: this.getId(),
                    token: this.getToken()
                }
            }));
            return d.logTrace("call.peer()", c.peer()), d.logTrace("call object", c), c.on("connected", function() {
                d.logDebug("call.on: connected"), null !== j.currentCall && (d.logInfo("Switching the calls..."), d.logTrace("From", j.currentCall.peer()), d.logTrace("To", j.pendingCall.peer()), h.publish("call:switched", {
                    from: j.currentCall.peer(),
                    to: j.pendingCall.peer(),
                    timestamp: new Date
                })), j.currentCall = j.pendingCall, j.pendingCall = null, j.addCall(j.currentCall)
            }), c.on("error", function() {
                d.logDebug("call.on: error"), c === j.pendingCall && (d.logInfo("Deleting pending call"), d.logTrace("session.pendingCall.peer", j.pendingCall.peer()), d.logTrace("session.pendingCall", j.pendingCall), j.pendingCall = null)
            }), this.pendingCall = c, d.logTrace("call.id", c.id()), d.logTrace("call object", c), c
        }, this.getCall = function(a) {
            return d.logDebug("ATT.rtc.Session: getCall"), d.logInfo("Getting call by id"), d.logTrace("callId", a), m[a]
        }, this.getCalls = function() {
            return d.logDebug("ATT.rtc.Session: getCalls"), d.logInfo("Getting all calls"), d.logTrace("calls", Object.keys(m)), m
        }, this.switchTo = function(a) {
            if (d.logDebug("ATT.rtc.Session: switchTo"), d.logInfo("Switching to call by callId"), d.logTrace("callId", a), void 0 === a) throw d.logError("You must pass a valid call id"), new Error("You must pass a valid call id");
            if (void 0 === m[a]) throw d.logError("Cannot find call with id " + a), new Error("Cannot find call with id " + a);
            h.publish("call:switched", {
                from: this.currentCall.peer(),
                to: m[a].peer(),
                timestamp: new Date
            }), this.currentCall = m[a], d.logTrace("currentCall.peer", this.currentCall.peer()), d.logTrace("currentCall", this.currentCall)
        }, this.terminateCalls = function() {
            d.logDebug("ATT.rtc.Session: terminateCalls"), d.logInfo("Terminating all the calls");
            var a;
            for (a in m) m.hasOwnProperty(a) && (d.logTrace("callId", a), d.logTrace("call.peer", m[a].peer()), m[a].disconnect())
        }, this.deleteCall = function(a) {
            if (d.logDebug("ATT.rtc.Session: deleteCall"), d.logInfo("Deleting a call by callId"), d.logTrace("callId", a), void 0 === m[a]) throw d.logError("Call not found"), new Error("Call not found");
            d.logInfo("Call deleted with peer " + m[a].peer()), d.logTrace("Call deleted", m[a]), delete m[a], 0 === Object.keys(m).length && (d.logInfo("All calls deleted from ATT.rtc.Session"), h.publish("all-calls-terminated"))
        }, this.deletePendingCall = function() {
            d.logDebug("ATT.rtc.Session: deletePendingCall"), d.logInfo("Deleting pending call"), null !== this.pendingCall && (d.logTrace("pendingCall.peer", this.pendingCall.peer()), d.logTrace("pendingCall", this.pendingCall), this.pendingCall = null)
        }, this.deleteCurrentCall = function() {
            d.logDebug("ATT.rtc.Session: deleteCurrentCall"), d.logInfo("Deleting current call"), null !== this.currentCall && (d.logTrace("currentCall.peer", this.currentCall.peer()), d.logTrace("currentCall", this.currentCall), this.deleteCall(this.currentCall.id()), this.currentCall = null)
        }, this.associateE911Id = function(a) {
            d.logDebug("ATT.rtc.Session: associateE911Id"), d.logInfo("Associating E911 ID"), d.logTrace("associateE911Id.options", a), i.associateE911Id(ATT.utils.extend(a, {
                sessionId: this.getId(),
                token: this.getToken(),
                onSuccess: function() {
                    d.logDebug("associateE911Id: onSuccess"), d.logInfo("Successfully associated E911 ID"), h.publish("address-updated")
                },
                onError: function(a) {
                    d.logDebug("associateE911Id: onError"), d.logError("Error during associating E911 ID"), d.logTrace(a), h.publish("error", {
                        error: a
                    })
                }
            }))
        }
    }
    var b = ATT["private"].factories,
        c = ATT["private"]["enum"],
        d = ATT.logManager.createLogger("session"),
        e = ATT["private"].config.app;
    if (d.logDebug("Loading att.rtc.session..."), void 0 === ATT.rtc) throw new Error("Cannot export Session. ATT.rtc is undefined");
    ATT.rtc.Session = a
}(),
function() {
    "use strict";

    function a() {
        function a(a) {
            return ia.getSDKError(a)
        }

        function e(b, c) {
            d.logDebug("ATT.rtc.Phone: publishError");
            var e = a(b),
                f = {};
            void 0 === e ? f.error = "TODO: Error not in dictionary" : f.error = e, void 0 !== c && (c instanceof Error ? f.data = {
                message: c.message
            } : "string" == typeof c ? f.data = {
                message: c
            } : f.data = {
                message: JSON.stringify(c)
            }), d.logError("error", JSON.stringify(f)), ga.publish("error", f)
        }

        function f(a) {
            d.logDebug("call.on: rejected"), d.logInfo("call:rejected event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("call:rejected", a), ha.deletePendingCall(), ja.stopUserMedia()
        }

        function g() {
            d.logDebug("Att.rtc.Phone: reject");
            try {
                var a = ha.pendingCall;
                if (null === a || null === a.id()) return void e("12000");
                try {
                    a.off("rejected", f), a.on("rejected", f), d.logInfo("Rejecting..."), a.reject()
                } catch (b) {
                    return d.logError("Error during reject"), d.logTrace(b), void e("12001")
                }
            } catch (b) {
                d.logError("Error during reject"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function h() {
            d.logDebug("ATT.rtc.Phone: rejectConference");
            try {
                if (null === ha || null === ha.getId()) return void e("22001");
                if (null === ha.pendingCall) return void e("22002");
                try {
                    var a = ha.pendingCall;
                    d.logTrace(a.peer(), a), a.on("rejected", function(a) {
                        d.logDebug("conference.on: rejected"), d.logInfo("conference:invitation-rejected event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:invitation-rejected", a), ha.deletePendingCall(), ja.stopUserMedia()
                    }), d.logInfo("Rejecting conference invite..."), a.reject()
                } catch (b) {
                    return d.logError("Error during reject conference"), d.logTrace(b), void e("22000")
                }
            } catch (b) {
                d.logError("Error during reject conference"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function i(a, b) {
            var c, e;
            for (d.logDebug("ATT.rtc.Phone: validOperation"), d.logTrace("Operation", a), d.logTrace("State", b), c = {
                mute: ["connected", "resumed", "unmuted"],
                unmute: ["resumed", "muted"],
                resume: ["held"],
                hold: ["connected", "resumed", "muted", "unmuted"]
            }, e = 0; e < c[a].length; e += 1)
                if (b === c[a][e]) return !0;
            return !1
        }

        function j(a) {
            ga.publish("call:moved", a)
        }

        function k(a) {
            var b = ha.currentCall;
            return ja.showStream({
                localOrRemote: "local",
                stream: b.localStream()
            }), ja.showStream({
                localOrRemote: "remote",
                stream: b.remoteStream()
            }), "conference" === b.breed() ? (d.logDebug("conference.on: resumed"), d.logInfo("conference:resumed event by ATT.rtc.Phone"), d.logTrace("data", a), void ga.publish("conference:resumed", a)) : (d.logDebug("call.on: resumed"), d.logInfo("call resumed by ATT.rtc.Phone"), d.logTrace("data", a), void ga.publish("call:resumed", a))
        }

        function l(a) {
            var b = ha.currentCall;
            return "conference" === b.breed() ? (d.logDebug("conference.on: held"), d.logInfo("conference:held event by ATT.rtc.Phone"), d.logTrace("data", a), void ga.publish("conference:held", a)) : (d.logDebug("call.on: held"), d.logInfo("call:held event by ATT.rtc.Phone"), d.logTrace("data", a), void ga.publish("call:held", a))
        }

        function m(a, b) {
            var c, e;
            return d.logDebug("ATT.rtc.Phone: onCallDisconnected"), d.logInfo("call:disconnected event by ATT.rtc.Phone"), d.logTrace("data", b), ga.publish("call:disconnected", b), ha.currentCall && a.id() === ha.currentCall.id() ? (d.logInfo("Deleting current call"), ha.deleteCurrentCall(), c = ha.getCalls(), ja.stopUserMedia(), e = Object.keys(c), d.logTrace("Remaining background calls", e.length), void(e.length > 0 && (d.logInfo("Setting background call as current call"), ha.currentCall = c[e[0]], "held" === ha.currentCall.getState() && ha.currentCall.autoresume && (d.logInfo("Resuming current call"), d.logTrace(ha.currentCall.peer(), ha.currentCall), ha.currentCall.off("resumed", k), ha.currentCall.on("resumed", k), ha.currentCall.resume())))) : ha.pendingCall && a.id() === ha.pendingCall.id() ? (d.logInfo("Deleting pending call"), d.logTrace(ha.pendingCall.peer(), ha.pendingCall), ha.deletePendingCall(), void ja.stopUserMedia()) : (d.logInfo("Deleting background call"), d.logTrace(a.peer(), a), ha.deleteCall(a.id()), void ja.stopUserMedia())
        }

        function n(a) {
            d.logDebug("call.on: canceled"), d.logInfo("call:canceled event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("call:canceled", a), ha.deletePendingCall(), ja.stopUserMedia()
        }

        function o(a) {
            d.logDebug("ATT.rtc.Phone: onSessionReady"), d.logTrace("data", a), ga.publish("session:ready", a)
        }

        function p(a) {
            d.logDebug("ATT.rtc.Phone: onSessionDisconnected"), d.logTrace("data", a), ga.publish("session:disconnected", a), ja.stopUserMedia(), ha.off("ready", o), ha.off("disconnected", p)
        }

        function q(a) {
            return a = a.replace(/\s/g, ""), a.indexOf("sip:") > -1 || a.indexOf("tel:") > -1 ? !0 : !1
        }

        function r(a) {
            d.logDebug("ATT.rtc.Phone: cleanPhoneNumber");
            try {
                return d.logInfo("Attempting to clean the phone number " + a), ATT.phoneNumber.cleanPhoneNumber(a)
            } catch (b) {
                d.logError("Error during cleanPhoneNumber"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function s(a) {
            d.logDebug("ATT.rtc.Phone: formatNumber");
            try {
                return d.logInfo("Attempting to format the phone number " + a), ATT.phoneNumber.formatNumber(a)
            } catch (b) {
                d.logError("Error during formatNumber"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function t(a) {
            if (void 0 === a) return null;
            var b, c, e = {};
            try {
                a.indexOf(";") > -1 && (b = a.split(";"), b.forEach(function(b, c) {
                    if (0 === c) a = b;
                    else if (b.indexOf("=") > -1) {
                        var d = b.split("=");
                        d.length > 0 && (e[d[0]] = 2 === d.length ? d[1] : "")
                    }
                })), a.indexOf(":") > -1 && (b = a.split(":"), e.protocol = b.length > 0 ? b[0] : "", a = b.length >= 2 ? b[1] : "", e.port = b.length >= 3 ? b[2] : ""), b = a.split("@"), e.callerId = b.length > 0 ? b[0] : "", e.domain = b.length >= 2 ? b[1] : "", c = new RegExp("^[+]?[0-9]+", "g"), e.callerId.match(c) || (e.callerId = e.callerId + "@" + e.domain)
            } catch (f) {
                d.logError("Error during getCallerInfo"), d.logTrace(f), ga.publish("error", {
                    error: f
                })
            }
            return e
        }

        function u(a, b) {
            if (d.logDebug("ATT.rtc.Phone: on"), d.logInfo("Subscribing to phone event: " + a), "session:ready" !== a && "session:disconnected" !== a && "session:call-switched" !== a && "session:expired" !== a && "notification" !== a && "dialing" !== a && "answering" !== a && "call:incoming" !== a && "call:connecting" !== a && "call:connected" !== a && "call:disconnecting" !== a && "call:disconnected" !== a && "call:muted" !== a && "call:unmuted" !== a && "call:held" !== a && "call:resumed" !== a && "call:canceled" !== a && "call:rejected" !== a && "call:moved" !== a && "call:transferring" !== a && "call:transferred" !== a && "address-updated" !== a && "call:ringback-provided" !== a && "media:established" !== a && "conference:invitation-received" !== a && "conference:joining" !== a && "conference:invitation-sending" !== a && "conference:invitation-rejected" !== a && "conference:connecting" !== a && "conference:invitation-sent" !== a && "conference:invitation-accepted" !== a && "conference:participant-removed" !== a && "conference:held" !== a && "conference:resumed" !== a && "conference:disconnecting" !== a && "conference:ended" !== a && "conference:canceled" !== a && "conference:connected" !== a && "warning" !== a && "error" !== a) throw new Error("Event " + a + " not defined");
            ga.unsubscribe(a, b), ga.subscribe(a, b, this)
        }

        function v() {
            d.logDebug("ATT.rtc.Phone: getCalls");
            var a, b, c, e, f = ha.getCalls(),
                g = [];
            d.logInfo("Getting list of calls...");
            for (a in f)
                if (f.hasOwnProperty(a)) {
                    if (d.logTrace("call id", a), b = {
                        index: f[a].index(),
                        state: f[a].getState(),
                        breed: f[a].breed(),
                        type: f[a].type()
                    }, "conference" === f[a].breed()) {
                        b.participants = [], e = f[a].participants(), d.logTrace("Participants", Object.keys(e).length);
                        for (c in e) e.hasOwnProperty(c) && (d.logTrace("participant", c), b.participants.push(e[c]))
                    } else b.peer = f[a].peer();
                    g.push(b)
                }
            return d.logTrace("Call List", g), g
        }

        function w() {
            return ha
        }

        function x(a) {
            d.logDebug("ATT.rtc.Phone: login"), d.logTrace("options", a);
            try {
                if (null !== ha.getId()) return void d.logInfo("User is already logged in!");
                if (void 0 === a) return void e("2002");
                if (void 0 === a.token) return void e("2001");
                try {
                    ha.off("ready", o), ha.on("ready", o), d.logInfo("logging in..."), ha.connect(a)
                } catch (b) {
                    return d.logError("Error during login"), d.logTrace(b), void e("2004")
                }
            } catch (b) {
                d.logError("Error during login"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function y(a) {
            if (d.logDebug("ATT.rtc: associateAccessToken"), d.logInfo("Associating access token  Domain"), void 0 === a || 0 === Object.keys(a).length) throw new Error("No options provided");
            if (void 0 === a.userId) throw new Error("No userId provided");
            if (void 0 === a.token) throw new Error("No token provided");
            if (void 0 === a.success) throw new Error("No success callback provided");
            if (void 0 === a.error) throw new Error("No error callback provided");
            var b = ATT["private"].rtcManager.getRTCManager();
            b.associateToken(a)
        }

        function z(a) {
            d.logDebug("ATT.rtc.Phone: associateE911Id");
            try {
                if (void 0 === a) return void e("17000");
                if (void 0 === ha || null === ha.getId()) return void e("17002");
                if (void 0 === a.e911Id || null === a.e911Id) return void e("17000");
                try {
                    ha.on("address-updated", function() {
                        d.logDebug("session.on: address-updated"), d.logInfo("address-updated event by ATT.rtc.Phone"), ga.publish("address-updated")
                    }), d.logTrace(ha.getId(), ha), d.logTrace("E911 Id", ha.e911Id), d.logInfo("Associating E911 Id..."), ha.associateE911Id(a)
                } catch (b) {
                    return d.logInfo("Error during associateE911Id"), d.logTrace(b), void e("17001")
                }
            } catch (b) {
                d.logInfo("Error during associateE911Id"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function A() {
            function a() {
                d.logDebug("session.on: all-calls-terminated"), d.logInfo("All calls were terminated successfully"), ha.off("all-calls-terminated", a), d.logInfo("logging out..."), ha.disconnect()
            }
            d.logDebug("ATT.rtc.Phone: logout"), ha.on("error", p);
            try {
                if (null === ha || null === ha.getId()) return void e("3001");
                try {
                    d.logInfo("logging out..."), ha.off("disconnected", p), ha.on("disconnected", p), null !== ha.pendingCall && (d.logInfo("Pending call exist. Deleting pending call..."), d.logTrace(ha.pendingCall.peer(), ha.pendingCall), ha.deletePendingCall()), Object.keys(ha.getCalls()).length > 0 ? (d.logInfo("Active calls exist. Attempting to disconnect active calls..."), ha.on("all-calls-terminated", a), ha.terminateCalls()) : (d.logInfo("logging out..."), ha.disconnect())
                } catch (b) {
                    return d.logError("Error during logout"), d.logTrace(b), void e("3000")
                }
            } catch (b) {
                d.logError("Error during logout"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function B() {
            d.logDebug("ATT.rtc.Phone: rejectCallOnMediaError"), d.logInfo("Rejecting incoming call");
            var a, b = ha.pendingCall;
            a = b.id(), b && void 0 !== a && null !== a && g()
        }

        function C(a, b, f) {
            d.logDebug("ATT.rtc.Phone: connectWithMediaStream"), d.logTrace("connectOpts", a), b.on("stream-added", function(a) {
                d.logDebug("call.on: stream-added"), ja.showStream({
                    stream: a.stream,
                    localOrRemote: "remote"
                })
            }), void 0 === a.mediaType && (a.mediaType = b.mediaType()), d.logInfo("Attempting to get user media"), ja.getUserMedia(ATT.utils.extend({
                onUserMedia: function(a) {
                    try {
                        d.logDebug("getUserMedia: onUserMedia"), d.logInfo("Got user media"), d.logTrace("media", a), b.addStream(a.localStream), d.logInfo("Connecting..."), b.connect()
                    } catch (c) {
                        d.logError("Error during onUserMedia"), d.logTrace(c), void 0 !== f && "function" == typeof f && f(c)
                    }
                },
                onMediaEstablished: function() {
                    if (d.logDebug("getUserMedia: onMediaEstablished"), d.logInfo("Remote media established"), null !== ha.pendingCall && "connecting" === ha.pendingCall.getState() && "call" === ha.pendingCall.breed()) return d.logInfo("Got early media"), d.logInfo("call:ringback-provided event by ATT.rtc.Phone"), void ga.publish("call:ringback-provided", {
                        timestamp: new Date
                    });
                    if (null !== ha.currentCall && "connected" === ha.currentCall.getState()) {
                        var a = {
                            mediaType: ha.currentCall.mediaType(),
                            codec: ha.currentCall.codec(),
                            timestamp: new Date
                        };
                        c.CALL_TYPE.OUTGOING === ha.currentCall.type() ? a.to = ha.currentCall.peer() : a.from = ha.currentCall.peer(), d.logInfo("media:established event by ATT.rtc.Phone"), ga.publish("media:established", a)
                    }
                },
                onUserMediaError: function(a) {
                    d.logDebug("getUserMedia: onUserMediaError"), d.logTrace(a),
                    B(), e("13005", a)
                }
            }, a))
        }

        function D(a) {
            d.logDebug("ATT.rtc.Phone: dial"), d.logTrace("options", a);
            var b;
            try {
                if (null === ha.getId()) return void e("4004");
                if (void 0 === a) return void e("4009");
                if (void 0 === a.localMedia || "VIDEO" !== a.localMedia.tagName && "AUDIO" !== a.localMedia.tagName) return void e("4006");
                if (void 0 === a.remoteMedia || "VIDEO" !== a.remoteMedia.tagName && "AUDIO" !== a.remoteMedia.tagName) return void e("4007");
                if (void 0 === a.destination) return void e("4008");
                if (void 0 !== a.mediaType && "audio" !== a.mediaType && "video" !== a.mediaType) return void e("4002");
                if (q(a.destination)) return void e("4000");
                if (ha.pendingCall) return void e("4010");
                if (a.destination.split("@").length > 2) return void e("4001");
                try {
                    ga.publish("dialing", {
                        to: a.destination,
                        mediaType: a.mediaType,
                        timestamp: new Date
                    }), b = ha.createCall({
                        peer: a.destination,
                        breed: "call",
                        type: c.CALL_TYPE.OUTGOING,
                        mediaType: a.mediaType,
                        localMedia: a.localMedia,
                        remoteMedia: a.remoteMedia
                    }), d.logTrace(b.peer(), b), b.on("connecting", function(a) {
                        d.logDebug("call.on: connecting"), d.logInfo("call:connecting event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("call:connecting", a)
                    }), b.on("rejected", f), b.on("connected", function(a) {
                        d.logDebug("call.on: connected"), d.logInfo("call:connected event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("call:connected", a)
                    }), b.on("disconnected", function(a) {
                        d.logDebug("call.on: disconnected"), m(b, a)
                    }), b.on("notification", function(a) {
                        d.logDebug("call.on: notification"), d.logInfo("notification event by ATT.rtc.Phone"), ga.publish("notification", a), ha.deletePendingCall(), ja.stopUserMedia()
                    }), b.on("error", function(a) {
                        return d.logDebug("call.on: error"), d.logError("error event by ATT.rtc.Phone"), d.logTrace("data", a), a.error && 404 === a.error.HttpStatusCode ? (d.logError("session:expired by ATT.rtc.Phone"), void ga.publish("session:expired", a)) : void ga.publish("error", a)
                    }), d.logInfo("Dialing..."), C(a, b, function(a) {
                        d.logError("Error during connectWthMediaStream"), d.logTrace(a), ga.publish("error", {
                            error: ATT.errorDictionary.getSDKError("4003"),
                            data: a
                        })
                    })
                } catch (g) {
                    return d.logError("Error during dial"), d.logTrace(g), void e("4003")
                }
            } catch (g) {
                d.logError("Error during dial"), d.logTrace(g), ga.publish("error", {
                    error: g
                })
            }
        }

        function E(a) {
            function b(e) {
                d.logDebug("ATT.rtc.Phone: dialSecondCall"), ga.publish("call:held", e), c.off("held", b), d.logInfo("Dialing second call..."), D(a)
            }
            d.logDebug("ATT.rtc.Phone: addCall"), d.logTrace("options", a);
            var c;
            if (2 <= v().length) return void e("27010");
            try {
                if (void 0 === a) return void e("27001");
                if (void 0 === a.localMedia || "VIDEO" !== a.localMedia.tagName && "AUDIO" !== a.localMedia.tagName) return void e("27002");
                if (void 0 === a.remoteMedia || "VIDEO" !== a.remoteMedia.tagName && "AUDIO" !== a.remoteMedia.tagName) return void e("27003");
                if (void 0 === a.destination) return void e("27004");
                if (q(a.destination)) return void e("27005");
                if (a.destination.split("@").length > 2) return void e("27006");
                if (void 0 !== a.mediaType && "audio" !== a.mediaType && "video" !== a.mediaType) return void e("27007");
                if (null === ha.getId()) return void e("27008");
                if (null === ha.currentCall) return void e("27009");
                try {
                    c = ha.currentCall, d.logInfo("Putting existing call on hold"), c.on("held", b), c.hold(), c.autoresume = !0
                } catch (f) {
                    return d.logError("Error during hold current call"), d.logTrace(f), void e("27000", f)
                }
            } catch (f) {
                d.logError("Error during addCall"), d.logTrace(f), ga.publish("error", {
                    error: f
                })
            }
        }

        function F(a, b) {
            d.logDebug("ATT.rtc.Phone: answerCall"), d.logTrace("options", b), ga.publish("answering", {
                from: a.peer(),
                mediaType: a.mediaType(),
                codec: a.codec(),
                timestamp: new Date
            }), a.on("connecting", function(a) {
                d.logDebug("call.on: connecting"), d.logInfo("call:connecting event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("call:connecting", a)
            }), a.on("connected", function(a) {
                d.logDebug("call.on: connected"), d.logInfo("call:connecting event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("call:connected", a)
            }), a.on("disconnected", function(b) {
                d.logDebug("call.on: disconnected"), m(a, b)
            }), a.on("notification", function(a) {
                d.logDebug("call.on: notification"), d.logInfo("call:connecting event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("notification", a), ha.deleteCurrentCall(), ja.stopUserMedia()
            }), a.on("error", function(a) {
                d.logDebug("call.on: error"), d.logError("error event by ATT.rtc.Phone"), d.logTrace("data", a), a.error && 404 === a.error.HttpStatusCode && (d.logError("session:expired by ATT.rtc.Phone"), ga.publish("session:expired", a)), ga.publish("error", a)
            }), d.logInfo("Answering..."), C(b, a)
        }

        function G(a) {
            function b() {
                d.logDebug("ATT.rtc.Phone: answerSecondCall"), d.logInfo("Answering second call"), c = "end" === a.action ? "disconnected" : "held", g.off(c, b), F(f, a)
            }
            d.logDebug("ATT.rtc.Phone: answer"), d.logTrace("options", a);
            var c, f, g;
            try {
                if (void 0 === a) return void e("5004");
                if (void 0 === a.localMedia || "VIDEO" !== a.localMedia.tagName && "AUDIO" !== a.localMedia.tagName) return void e("5001");
                if (void 0 === a.remoteMedia || "VIDEO" !== a.remoteMedia.tagName && "AUDIO" !== a.remoteMedia.tagName) return void e("5001");
                if (null === ha.getId()) return void e("5003");
                if (f = ha.pendingCall, null === f) return void e("5000");
                if (void 0 !== a.action && "hold" !== a.action && "end" !== a.action) return void e("5005");
                if (g = ha.currentCall, null !== g) {
                    if (d.logTrace(g.peer(), g), d.logInfo("There is an existing call"), void 0 === a.action) return void e("5005");
                    if ("hold" === a.action) {
                        if ("held" !== g.getState()) return d.logInfo("Putting the current call on hold"), g.on("held", b), g.hold(), void(g.autoresume = !0);
                        b(f, a, !0)
                    }
                    return void("end" === a.action && (d.logInfo("Ending the current call"), g.on("disconnected", b), g.disconnect()))
                }
                void 0 !== a.action && d.logWarning("There is no current call. Action `" + a.action + "` will be ignored"), F(f, a)
            } catch (h) {
                return d.logError("Error during answer"), d.logTrace(h), void e("5002", h)
            }
        }

        function H() {
            d.logDebug("ATT.rtc.Phone: hangup");
            var a;
            try {
                if (a = ha.currentCall, null === a || null === a.id()) return void e("6000");
                try {
                    d.logTrace(a.peer(), a), a.on("disconnecting", function(a) {
                        d.logDebug("call.on: disconnecting"), d.logInfo("call:disconnecting event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("call:disconnecting", a)
                    }), d.logInfo("Hanging up..."), a.disconnect()
                } catch (b) {
                    return d.logError("Error during hangup"), d.logTrace(b), void e("6001")
                }
            } catch (b) {
                d.logError("Error during hangup"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function I() {
            d.logDebug("Att.rtc.Phone: cancel");
            var a = ha.pendingCall;
            try {
                if (null === a) return void e("11000");
                try {
                    d.logTrace(a.peer(), a), a.off("canceled", n), a.on("canceled", n), d.logInfo("Canceling..."), a.disconnect()
                } catch (b) {
                    return d.logError("Error during cancel"), d.logTrace(b), void e("11001")
                }
            } catch (b) {
                d.logError("Error during cancel"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function J(a) {
            d.logDebug("ATT.rtc.Phone: startConference"), d.logTrace("options", a);
            var b;
            try {
                if (void 0 === a || 0 === Object.keys(a).length) return d.logError("No options provided"), void e("18000");
                if (void 0 === ha || null === ha.getId()) return d.logError("Cannot start session. user is not logged in"), void e("18007");
                if (null !== ha.currentCall && "conference" === ha.currentCall.breed()) return d.logError("Cannot start conference. Another conference already exists"), void e("18006");
                if (void 0 === a.localMedia || "VIDEO" !== a.localMedia.tagName && "AUDIO" !== a.localMedia.tagName) return d.logError("localMedia not provided"), void e("18001");
                if (void 0 === a.remoteMedia || "VIDEO" !== a.remoteMedia.tagName && "AUDIO" !== a.remoteMedia.tagName) return d.logError("remoteMedia not provided"), void e("18002");
                if (void 0 === a.mediaType || "audio" !== a.mediaType && "video" !== a.mediaType) return d.logError("mediaType not provided"), void e("18003");
                a.breed = "conference", a.type = c.CALL_TYPE.OUTGOING, b = ha.createCall(a), d.logTrace(b.peer(), b), b.on("error", function(a) {
                    d.logDebug("conference.on: error"), d.logError("error event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("error", a)
                }), b.on("connected", function(a) {
                    d.logDebug("conference.on: connected"), d.logInfo("conference:connected event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:connected", a)
                }), b.on("response-pending", function(a) {
                    d.logDebug("conference.on: response-pending"), d.logInfo("conference:invitation-sent event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:invitation-sent", a)
                }), b.on("invite-accepted", function(a) {
                    d.logDebug("conference.on: invite-accepted"), d.logInfo("conference:invitation-accepted event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:invitation-accepted", a)
                }), b.on("rejected", function(a) {
                    d.logDebug("conference.on: rejected"), d.logInfo("conference:invitation-rejected event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:invitation-rejected", a)
                }), b.on("notification", function(a) {
                    d.logDebug("conference.on: notification"), d.logInfo("notification event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("notification", a)
                }), b.on("participant-removed", function(a) {
                    d.logDebug("conference.on: participant-removed"), d.logInfo("conference:participant-removed event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:participant-removed", a)
                }), b.on("disconnected", function(a) {
                    d.logDebug("conference.on: disconnected"), d.logInfo("conference:ended event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:ended", a), ha.deleteCurrentCall(), ja.stopUserMedia()
                }), d.logInfo("Starting conference..."), C(a, b)
            } catch (f) {
                return void e("18005", f)
            }
        }

        function K(a) {
            d.logDebug("ATT.rtc.Phone: joinConference"), d.logTrace("options", a);
            try {
                if (null === ha || null === ha.getId()) return void e("20001");
                if (null === ha.pendingCall) return void e("20002");
                try {
                    var b = ha.pendingCall;
                    d.logTrace(b.peer(), b), ga.publish("conference:joining", {
                        from: b.peer(),
                        mediaType: b.mediaType(),
                        codec: b.codec(),
                        timestamp: new Date
                    }), b.on("error", function(a) {
                        d.logDebug("conference.on: error"), d.logError("error event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("error", a)
                    }), b.on("connecting", function(a) {
                        d.logDebug("conference.on: connecting"), d.logInfo("conference:connecting event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:connecting", a)
                    }), b.on("connected", function(a) {
                        d.logDebug("conference.on: connected"), d.logInfo("conference:connected event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:connected", a)
                    }), b.on("disconnected", function(a) {
                        d.logDebug("conference.on: disconnected"), d.logInfo("conference:ended event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:ended", a), ha.deleteCurrentCall(), ja.stopUserMedia()
                    }), b.on("notification", function(a) {
                        d.logDebug("conference.on: notification"), d.logInfo("notification event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("notification", a), ha.deleteCurrentCall(), ja.stopUserMedia()
                    }), d.logInfo("Joining conference..."), C(a, b, function(a) {
                        d.logError("Error during connectWithMediaStream"), d.logTrace(a), ga.publish("error", {
                            error: ATT.errorDictionary.getSDKError("20000"),
                            data: a
                        })
                    })
                } catch (c) {
                    return d.logError("Error during joinConference"), d.logTrace(c), void e("20000")
                }
            } catch (c) {
                d.logError("Error during joinConference"), d.logTrace(c), ga.publish("error", {
                    error: c
                })
            }
        }

        function L(a) {
            d.logDebug("ATT.rtc.Phone: addParticipants"), d.logTrace("participants", a);
            var b, c, f, g, h, i;
            try {
                if (void 0 === a) return d.logError("Parameter missing"), void e("24000");
                if ("object" != typeof a || null === a || 0 === Object.keys(a).length) return void e("24001");
                if (null === ha.getId()) return void e("24002");
                if (b = ha.currentCall, d.logTrace(b.peer(), b), "conference" !== b.breed()) return d.logError("Conference not initiated "), void e("24003");
                for (d.logInfo("Getting list of current participants"), h = b.participants(), d.logTrace("currentParticipants", h), d.logInfo("Validating list of participants to add"), c = 0; c < a.length; c += 1) {
                    if (f = a[c], q(f)) return void e("24006");
                    if (f.split("@").length > 2) return void e("24007");
                    a[c] = f
                }
                d.logTrace("participants", a);
                try {
                    for (d.logInfo("Adding Participant..."), i = function(a) {
                        ga.publish("conference:invitation-sending", {
                            invitee: a,
                            timestamp: new Date
                        }), b.addParticipant(a)
                    }, c = 0; c < a.length; c += 1)
                        if (d.logInfo(c), f = a[c], d.logTrace("invitee", f), 0 === Object.keys(h).length) i(f);
                        else {
                            for (g in h)
                                if (h.hasOwnProperty(g) && f === g) return void e("24005", {
                                    invitee: f,
                                    timestamp: new Date
                                });
                            i(f)
                        }
                } catch (j) {
                    return d.logInfo("Error during addParticipants"), d.logTrace(j), void e("24004", j)
                }
            } catch (j) {
                d.logInfo("Error during addParticipants"), d.logTrace(j), ga.publish("error", {
                    error: j
                })
            }
        }

        function M(a) {
            d.logDebug("ATT.rtc.Phone: addParticipant"), d.logTrace("invitee", a);
            try {
                if (void 0 === a) return void e("19000");
                try {
                    d.logInfo("Adding Participant..."), this.addParticipants([a])
                } catch (b) {
                    return d.logInfo("Error during addParticipant"), d.logTrace(b), void e("19001", b)
                }
            } catch (b) {
                d.logInfo("Error during addParticipant"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function N() {
            d.logDebug("ATT.rtc.Phone: getParticipants");
            var a, b;
            try {
                if (null === ha.getId()) return void e("21002");
                if (a = ha.currentCall, null === a || "conference" !== a.breed()) return void e("21000");
                try {
                    return d.logTrace(a.peer(), a), d.logInfo("Getting participants..."), b = a.participants(), d.logTrace("participants", b), b
                } catch (c) {
                    return d.logError("Error during getParticipants"), d.logTrace(c), void e("21001", c)
                }
            } catch (c) {
                d.logError("Error during getParticipants"), d.logTrace(c), ga.publish("error", {
                    error: c
                })
            }
        }

        function O(a) {
            d.logDebug("ATT.rtc.Phone: removeParticipant");
            var b;
            try {
                if (null === ha.getId()) return void e("25000");
                if (b = ha.currentCall, null === b || "conference" !== b.breed()) return void e("25001");
                if (void 0 === a) return void e("25002");
                try {
                    d.logTrace(b.peer(), b), d.logInfo("Removing participant"), b.removeParticipant(a)
                } catch (c) {
                    return d.logError("Error during removeParticipant"), d.logTrace(c), void e("25003")
                }
            } catch (c) {
                d.logError("Error during removeParticipant"), d.logTrace(c), ga.publish("error", {
                    error: c
                })
            }
        }

        function P() {
            d.logDebug("ATT.rtc.Phone: endConference");
            var a;
            try {
                if (null === ha.getId()) return void e("23001");
                if (a = ha.currentCall, null === a || "conference" !== a.breed()) return void e("23002");
                d.logTrace(a.peer(), a), a.on("disconnecting", function(a) {
                    d.logDebug("conference.on: disconnecting"), d.logInfo("conference:disconnecting event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("conference:disconnecting", a)
                });
                try {
                    d.logInfo("Disconnecting conference"), a.disconnectConference()
                } catch (b) {
                    return d.logError("Error during endConference"), d.logTrace(b), void e("23000", b)
                }
            } catch (b) {
                d.logError("Error during endConference"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function Q() {
            d.logDebug("ATT.rtc.Phone: mute");
            try {
                var a = ha.currentCall;
                if (null === a || null === a.id) return void e("9000");
                try {
                    if (d.logTrace(a.peer(), a), a.on("muted", function(a) {
                        d.logDebug("call.on: muted"), d.logInfo("call:muted event by ATT.rtc.Phone"), ga.publish("call:muted", a)
                    }), "muted" === a.getState()) return d.logWarning("warning event by ATT.rtc.Phone"), void ga.publish("warning", {
                        message: "Already muted"
                    });
                    if (i("mute", a.getState())) return d.logInfo("Muting..."), void a.mute();
                    d.logWarning("Invalid operation mute. Call state is " + a.getState())
                } catch (b) {
                    return d.logError("Error during mute"), d.logTrace(b), void e("9001")
                }
            } catch (b) {
                d.logError("Error during mute"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function R() {
            d.logDebug("ATT.rtc.Phone: unmute");
            try {
                var a = ha.currentCall;
                if (null === a || null === a.id) return void e("10000");
                try {
                    if (d.logTrace(a.peer(), a), a.on("unmuted", function(a) {
                        d.logDebug("call.on: unmuted"), d.logInfo("call:unmuted event by ATT.rtc.Phone"), ga.publish("call:unmuted", a)
                    }), "unmuted" === a.getState()) return d.logWarning("warning event by ATT.rtc.Phone"), void ga.publish("warning", {
                        message: "Already unmuted"
                    });
                    if (i("unmute", a.getState())) return d.logInfo("Unmuting..."), void a.unmute();
                    d.logWarning("Invalid operation unmute. Call state is " + a.getState())
                } catch (b) {
                    return d.logError("Error during unmute"), d.logTrace(b), void e("10001")
                }
            } catch (b) {
                d.logError("Error during unmute"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function S() {
            d.logDebug("ATT.rtc.Phone: hold");
            var a;
            a = ha.currentCall;
            try {
                if (d.logTrace(a.peer(), a), null === a || null === a.id()) return void e("7000");
                if ("held" === a.getState()) return d.logWarning("Call is already on hold"), void ga.publish("warning", {
                    message: "Call is already on hold",
                    timestamp: new Date
                });
                try {
                    if (i("hold", a.getState())) return d.logInfo("Holding..."), a.off("held", l), a.on("held", l), void a.hold();
                    d.logWarning("Invalid operation hold. Call state is " + a.getState())
                } catch (b) {
                    return d.logError("Error during hold"), d.logTrace(b), void e("7001")
                }
            } catch (b) {
                d.logError("Error during hold"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function T() {
            d.logDebug("ATT.rtc.Phone: resume");
            var a;
            a = ha.currentCall;
            try {
                if (null === a) return void e("8000");
                if (d.logTrace(a.peer(), a), !i("resume", a.getState())) return void e("8001");
                try {
                    d.logInfo("Resuming..."), a.off("resumed", k), a.on("resumed", k), a.resume()
                } catch (b) {
                    return d.logError("Error during resume"), d.logTrace(b), void e("8002")
                }
            } catch (b) {
                d.logError("Error during resume"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function U() {
            d.logDebug("ATT.rtc.Phone: move");
            var a;
            try {
                if (null === ha || null === ha.getId()) return void e("28000");
                if (a = ha.currentCall, null === a || null === a.id()) return void e("28001");
                try {
                    d.logTrace(a.peer(), a), d.logInfo("Moving..."), a.off("moved", j), a.on("moved", j), a.move()
                } catch (b) {
                    return d.logError("Error during move"), d.logTrace(b), void e("28002")
                }
            } catch (b) {
                d.logError("Error during move"), d.logTrace(b), ga.publish("error", {
                    error: b
                })
            }
        }

        function V() {
            function a() {
                d.logDebug("ATT.rtc.Phone: switchToCall");
                var c, e, f;
                b.off("held", a), e = ha.getCalls();
                for (c in e)
                    if (e.hasOwnProperty(c) && c !== b.id()) {
                        f = c;
                        break
                    }
                d.logInfo("Switching calls..."), d.logTrace("Switch to call id", f), ha.switchTo(f), b = ha.currentCall, "held" === b.getState() && b.autoresume && (d.logInfo("resuming current call"), b.off("resumed", k), b.on("resumed", k), b.resume(), b.autoresume = !1)
            }
            d.logDebug("ATT.rtc.Phone: switchCall");
            var b = ha.currentCall;
            try {
                if (null === ha || null === ha.getId()) return void e(30001);
                if (null === ha.currentCall || null === ha.currentCall.id()) return void e(30002);
                if (2 > Object.keys(ha.getCalls()).length) return void e(30003);
                if (d.logTrace(b.peer(), b), "held" !== b.getState()) return d.logInfo("Putting current call on hold"), b.on("held", a), b.hold(), void(b.autoresume = !0);
                a()
            } catch (c) {
                return d.logError("Error during switch"), d.logTrace(c), void e(3e4)
            }
        }

        function W() {
            function a(a) {
                ga.publish("call:transferring", a)
            }

            function b(a) {
                ga.publish("call:transferred", a)
            }
            d.logDebug("ATT.rtc.Phone: transfer");
            var c, f, g, h;
            try {
                if (null === ha || null === ha.getId()) return void e("29001");
                if (c = ha.currentCall, null === c || null === c.id()) return void e("29002");
                if (2 > Object.keys(ha.getCalls()).length) return void e("29004");
                try {
                    d.logTrace("currentCall", c.peer()), d.logTrace("currentCall id", c.id()), f = ha.getCalls();
                    for (g in f)
                        if (f.hasOwnProperty(g) && g !== ha.currentCall.id()) {
                            h = ha.getCall(g);
                            break
                        }
                    d.logTrace("backgroundCall", h.peer()), d.logTrace("backgroundCall id", h.peer()), h.off("transferred", b), h.on("transferred", b), h.off("transferring", a), h.on("transferring", a), d.logInfo("Transferring call with peer " + h.peer() + " to " + c.peer()), h.transfer({
                        targetCallId: c.id()
                    })
                } catch (i) {
                    return d.logError("Error during transfer call"), d.logTrace(i), void e("29000", i)
                }
            } catch (i) {
                d.logError("Error during transfer call"), d.logTrace(i), ga.publish("error", {
                    error: i
                })
            }
        }

        function X() {
            d.logDebug("ATT.rtc.Phone: getMediaType"), d.logInfo("Getting current call media type...");
            var a = ha.currentCall;
            return d.logTrace(a.peer(), a), d.logTrace("MediaType", a.mediaType()), a ? a.mediaType() : null
        }

        function Y() {
            d.logDebug("ATT.rtc.Phone: isCallInProgress"), d.logInfo("Checking if current call exists...");
            var a = ha.currentCall;
            return null !== a ? (d.logTrace("Call in progress", !0), d.logTrace(a.peer(), a), !0) : (d.logTrace("Call in progress", !1), !1)
        }

        function Z() {
            return d.logDebug("ATT.rtc.phone: getIceServers"), d.logInfo("getting current iceServer value of peerConnection"), d.logTrace("iceServers", ha.currentPcConfiguration.iceServers), JSON.stringify(ha.currentPcConfiguration.iceServers)
        }

        function $(a) {
            d.logDebug("ATT.rtc.phone: setIceServer"), d.logInfo("sets the new iceServer value to peerConnection"), "object" != typeof a && e("40000"), d.logTrace("iceServers", a), ha.currentPcConfiguration.iceServers = a
        }

        function _() {
            d.logDebug("ATT.rtc.phone: resetIceServers"), d.logInfo("Reset iceServer value of peerConnection to default"), d.logTrace("default IceServer", ha.defaultPcConfiguration.iceServers), ha.currentPcConfiguration.iceServers = ha.defaultPcConfiguration.iceServers
        }

        function aa() {
            return d.logDebug("ATT.rtc.phone: getIceTransport"), d.logInfo("getting current iceTranport value of peerConnection"), d.logTrace("iceTransports", ha.currentPcConfiguration.iceTransports), ha.currentPcConfiguration.iceTransports
        }

        function ba(a) {
            d.logDebug("ATT.rtc.phone: setIceTransport"), d.logInfo("sets the new iceTransport value to peerConnection"), "string" != typeof a && e("50000"), "all" !== a && "none" !== a && "relay" !== a && e("50001"), d.logTrace("iceTransports", a), ha.currentPcConfiguration.iceTransports = a
        }

        function ca() {
            d.logDebug("ATT.rtc.phone: resetIceTransport"), d.logInfo("Reset iceTransport value of peerConnection to default"), d.logTrace("Default iceTransport", ha.defaultPcConfiguration.iceTransports), ha.currentPcConfiguration.iceTransports = ha.defaultPcConfiguration.iceTransports
        }

        function da() {
            return d.logDebug("ATT.rtc.phone: getIpv6"), d.logInfo("getting current ipv6 value of peerConnection"), d.logTrace("ipv6", ha.currentPcConfiguration.ipv6), ha.currentPcConfiguration.ipv6
        }

        function ea(a) {
            d.logDebug("ATT.rtc.phone: setIpv6"), d.logInfo("sets the new ipv6 value to peerConnection"), "boolean" != typeof a && e("60000"), d.logTrace("ipv6", a), ha.currentPcConfiguration.ipv6 = a
        }

        function fa() {
            d.logDebug("ATT.rtc.phone: resetIpv6"), d.logInfo("Reset ipv6 value of peerConnection to default"), d.logTrace("Default Ipv6", ha.defaultPcConfiguration.ipv6), ha.currentPcConfiguration.ipv6 = ha.defaultPcConfiguration.ipv6
        }
        var ga = b.createEventEmitter(),
            ha = new ATT.rtc.Session,
            ia = ATT.errorDictionary,
            ja = ATT.UserMediaService;
        d.logDebug("ATT.rtc.Phone: Constructor"), d.logInfo("Creating a new instance of Phone"), ha.on("call:incoming", function(a) {
            function b(c) {
                null !== ha.pendingCall && c.id() === ha.pendingCall.id() && (ga.publish("call:canceled", a), c.off("canceled", b), d.logInfo("Deleting canceled pending call"), d.logTrace(c.peer(), c), ha.deletePendingCall(), ja.stopUserMedia())
            }

            function c(b) {
                null !== ha.pendingCall && b.id() === ha.pendingCall.id() && (ga.publish("call:disconnected", a), b.off("disconnected", c), d.logInfo("Deleting disconnected pending call"), d.logTrace(b.peer(), b), ha.deletePendingCall(), ja.stopUserMedia())
            }
            return d.logDebug("session.on: call:incoming"), d.logInfo("call:incoming event  by ATT.rtc.Phone"), d.logTrace("data", a), null !== ha.currentCall && "conference" === ha.currentCall.breed() && "call" === ha.pendingCall.breed() ? (d.logError("Cannot accept incoming call. An active conference is already going on"), e("1006"), void ha.pendingCall.reject()) : (ga.publish("call:incoming", a), void(ha.pendingCall && (d.logTrace(ha.pendingCall.peer(), ha.pendingCall), ha.pendingCall.on("canceled", b.bind(null, ha.pendingCall)), ha.pendingCall.on("disconnected", c.bind(null, ha.pendingCall)))))
        }), ha.on("conference-invite", function(a) {
            function b(c) {
                null !== ha.pendingCall && c.id() === ha.pendingCall.id() && (ga.publish("conference:canceled", a), c.off("canceled", b), d.logInfo("Deleting canceled pending call"), d.logTrace(c.peer(), c), ha.deletePendingCall(), ja.stopUserMedia())
            }

            function c(b) {
                null !== ha.pendingCall && b.id() === ha.pendingCall.id() && (ga.publish("conference:ended", a), b.off("disconnected", c), d.logInfo("Deleting disconnected pending call"), d.logTrace(b.peer(), b), ha.deletePendingCall(), ja.stopUserMedia())
            }
            return d.logDebug("session.on: conference-invite"), d.logInfo("conference:invitation-received event by ATT.rtc.Phone"), d.logTrace("data", a), null !== ha.currentCall && "call" === ha.currentCall.breed() && "conference" === ha.pendingCall.breed() ? (d.logError("Cannot join conference. An active call is already going on"), e("1005"), void ha.deletePendingCall()) : null !== ha.currentCall && "conference" === ha.currentCall.breed() && "conference" === ha.pendingCall.breed() ? (d.logError("Cannot accept incoming conference. An active conference is already going on"), e("1007"), void ha.deletePendingCall()) : (ga.publish("conference:invitation-received", a), void(ha.pendingCall && (d.logTrace(ha.pendingCall.peer(), ha.pendingCall), ha.pendingCall.on("canceled", b.bind(null, ha.pendingCall)), ha.pendingCall.on("disconnected", c.bind(null, ha.pendingCall)))))
        }), ha.on("call:switched", function(a) {
            d.logDebug("session.on: call:switched"), d.logInfo("session:call-switched event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("session:call-switched", a)
        }), ha.on("notification", function(a) {
            d.logDebug("session.on: notification"), d.logInfo("notification event by ATT.rtc.Phone"), d.logTrace("data", a), ga.publish("notification", a)
        }), ha.on("error", function(a) {
            return d.logDebug("session.on: error"), d.logError("error event by ATT.rtc.Phone"), d.logTrace("data", a), a.error && 404 === a.error.HttpStatusCode ? (d.logError("session:expired by ATT.rtc.Phone"), void ga.publish("session:expired", a)) : void ga.publish("error", a)
        }), this.on = u, this.getSession = w, this.login = x, this.associateAccessToken = y, this.associateE911Id = z, this.logout = A, this.dial = D, this.addCall = E, this.answer = G, this.hangup = H, this.cancel = I, this.reject = g, this.move = U, this.transfer = W, this.startConference = J, this.joinConference = K, this.endConference = P, this.rejectConference = h, this.addParticipants = L, this.addParticipant = M, this.getParticipants = N, this.removeParticipant = O, this.mute = Q, this.unmute = R, this.hold = S, this.resume = T, this.switchCall = V, this.getCalls = v, this.getMediaType = X, this.isCallInProgress = Y, this.cleanPhoneNumber = r, this.formatNumber = s, this.getCallerInfo = t, this.getIceServers = Z, this.setIceServers = $, this.resetIceServers = _, this.getIceTransport = aa, this.setIceTransport = ba, this.resetIceTransport = ca, this.getIpv6 = da, this.setIpv6 = ea, this.resetIpv6 = fa
    }
    var b = ATT["private"].factories,
        c = ATT["private"]["enum"],
        d = ATT.logManager.createLogger("phone");
    if (d.logDebug("Loading att.rtc.phone..."), void 0 === ATT["private"]) throw new Error("Error exporting ATT.private.Phone.");
    if (ATT["private"].Phone = a, void 0 === ATT.rtc) throw new Error("Error exporting ATT.rtc.Phone.");
    ATT.rtc.Phone = function() {
        var b;
        return {
            getPhone: function() {
                return d.logDebug("ATT.rtc.Phone: getPhone"), void 0 === b && (b = new a), b
            }
        }
    }()
}(),
function() {
    "use strict";
    var a, b = ATT.logManager.createLogger("main");
    return b.logDebug("Loading att.main..."), b.logInfo("Attempting to load Enhanced WebRC SDK..."), void 0 === window.ATT ? void b.logError("Cannot load ATT's Enhanced WebRTC SDK. ATT is not defined.") : (a = window.ATT, window.ATT = void 0, "Not Supported" === a.browser.hasWebRTC() ? (window.ATT = {
        browser: a.browser
    }, void b.logError("Failed to load ATT's Enhanced WebRTC SDK. The browser doesn't support Enhanced WebRTC")) : (window.ATT = a, b.logInfo("Loading error dictionary..."), void 0 === ATT.utils.createErrorDictionary ? void b.logError("Failed to load error dictionary. Missing ATT.utils.createErrorDictionary.") : (ATT.errorDictionary = ATT.utils.createErrorDictionary(ATT.utils.ErrorStore.SDKErrors.getAllSDKErrors(), ATT.utils.ErrorStore.APIErrors.getAllAPIErrors()), (void 0 === ATT.errorDictionary || null === ATT.errorDictionary) && b.logError("Failed to create error dictionary"), b.logInfo("Loading error dictionary complete"), void b.logInfo("Loading Enhanced WebRC SDK complete"))))
}();